<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Build Your Own RTOS Part4：PendSV</title>
      <link href="/2025/12/15/2025-12-15-RTOS4/"/>
      <url>/2025/12/15/2025-12-15-RTOS4/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Build Your Own RTOS 系列文章</strong>：</p><ol><li><a href="/2025/12/10/2025-12-10-RTOS1/" title="Build Your Own RTOS Part1：理解M3架构的寄存器">理解M3架构</a></li><li><a href="/2025/12/12/2025-12-12-RTOS2/" title="Build Your Own RTOS Part2：硬件自动压栈">硬件自动压栈</a></li><li><a href="/2025/12/13/2025-12-13-RTOS3/" title="Build Your Own RTOS Part3：初始化栈">初始化栈</a></li><li><strong>当前阅读：PendSV</strong></li></ol></blockquote><h2 id="1-PendSV"><a href="#1-PendSV" class="headerlink" title="1 PendSV"></a>1 PendSV</h2><p>在前几期中，我们已经理解了寄存器，学会了如何模仿硬件压栈来完成上下文切换。本期我们就要在<code>PendSV_Handler()</code>中实现它。</p><h3 id="1-1-什么是PendSV？"><a href="#1-1-什么是PendSV？" class="headerlink" title="1.1 什么是PendSV？"></a>1.1 什么是PendSV？</h3><p>PendSV（Pendable Service Call，可挂起的系统调用）是CM3内核专门设计的一种异常。就如字面所述，它是可以“挂起”（等待）的。</p><p>如果没有PendSV，我们可能要在别的中断（例如SysTick中）完成上下文切换。试想一下，我们正在处理紧急的硬件中断（或其他高优先级的任务），这时SysTick过来，不分青红皂白的切换上下文，直接让CPU去执行别的普通任务，原任务就被搁置了，这对我们的系统是致命的。</p><p>但是有了PendSV就不一样了。我们通常把PendSV的优先级设置成全系统最低（优先级号越大，优先级越低）。当SysTick触发任务切换的指令时，系统会先检查有没有比PendSV优先级更高的中断，如果有就先去执行优先级高的，直到最后只剩下PendSV，此时才执行任务切换。</p><h3 id="1-2-为什么PendSV-Handler-只能用汇编写？"><a href="#1-2-为什么PendSV-Handler-只能用汇编写？" class="headerlink" title="1.2 为什么PendSV_Handler()只能用汇编写？"></a>1.2 为什么<code>PendSV_Handler()</code>只能用汇编写？</h3><p>因为编译器太智能了，它会在你看不到的地方，在你手写的C语言函数代码前后添加一堆乱七八糟的东西（<strong>Prologue</strong>和<strong>Epilogue</strong>），虽然对于普通的代码而言无关紧要，但是对<code>PendSV_Handler()</code>这种高要求的操作，会出现大麻烦。所以，涉及到这种底层寄存器的操作，我们只能使用纯汇编来写。<em>幸运的是，之后基本就不用了。</em></p><h3 id="1-3-实现逻辑"><a href="#1-3-实现逻辑" class="headerlink" title="1.3 实现逻辑"></a>1.3 实现逻辑</h3><p>我们现在就正式开始准备实现<code>PendSV_Handler()</code>。由于我们还没有写调度，所以今天我们先写一个简单版，等到后面我们再把内容添加进来。</p><p>为了切换任务，我们需要两个指针来分别指向当前的任务和下一个要运行的任务。我们用<code>CurrentTCB</code>和<code>NextTCB</code>来表示。</p><p>首先我们要明确：<code>PendSV_Handler()</code>要做些什么。假设我们已经有了两个任务，任务1的运行时间到了，接下来准备执行任务2。那么我们怎么处理现在寄存器里的数据呢？</p><ol><li>先把现在正在用的数据存起来。第一步：获取当前PSP的值，存在R0里。由于R0-R3被硬件自动压栈了，所以存在R0里是安全的。然后，再把硬件没存的寄存器手动存到R0此刻指向的地址，也就是和硬件自动存储的数据放在一起。最后把<code>CurrentTCB</code>的值（也就是当前执行任务的TCB的地址）读出来放进R1，再把此刻R0的值存到R1指向的地址。</li><li>接下来就是恢复现场，把任务2的数据拿回来。首先把<code>NextTCB</code>的值写入<code>CurrentTCB</code>，现在的<code>CurrentTCB</code>已经是新的任务了。然后获取<code>CurrentTCB</code>的<code>sp</code>，从这个地址中弹出数据到R4-R11，最后更新PSP。至此，任务切换结束。</li></ol><p>好了，逻辑基本讲清楚了，我们就开始写代码。把<code>PendSV_Handler()</code>函数的代码写在<code>os_cpu_a.s</code>中。我们需要在函数的开头使用<code>CPSID I</code>关中断、结尾<code>BX LR</code>前使用<code>CPSIE I</code>开中断来制造临界区。这在实际应用中是不需要甚至<strong>应该避免</strong>的，但是为了今天的调试和学习，我们先这么做，防止别的中断打断我们的逻辑。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        点击查看答案    </div>    <div class='spoiler-content'>        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PendSV_Handler PROC  ; PROC代表函数的开头</span><br><span class="line">    CPSID I ; 关中断</span><br><span class="line">    MRS R0, PSP</span><br><span class="line">    ISB ; 指令同步隔离，确保程序生效</span><br><span class="line"></span><br><span class="line">    STMDB R0!, &#123;R4-R11&#125;</span><br><span class="line"></span><br><span class="line">    LDR R2, =CurrentTCB ; 现在R2里存的是CurrentTCB的地址</span><br><span class="line">    LDR R1, [R2] ; 把R2（CurrentTCB）地址中所存的值（就是TCB的首地址，也就是sp变量的地址）存到R1里</span><br><span class="line">    STR R0, [R1] ; 把现在的R0（也就是PSP最终指向的地址）存到R1指向的地址（也就是存进sp变量）</span><br><span class="line"></span><br><span class="line">    LDR R2, =NextTCB ; 现在R2里存的是NextTCB的地址</span><br><span class="line">    LDR R3, =CurrentTCB ; 现在R3里存的是CurrentTCB的地址</span><br><span class="line">    LDR R1, [R3] ; 把R3（CurrentTCB）地址中所存的值存到R1里</span><br><span class="line">    STR R1, [R2] ; 把R1（NextTCB的sp变量）存到CurrentTCB的地址所对应的内存中，现在CurrentTCB已经是新的任务了</span><br><span class="line">    LDR R0, [R1] ; 从R1（NextTCB的sp变量）所对应的内存中读取NextTCB（实际上就是CurrentTCB）的sp变量到R0</span><br><span class="line">    LDMIA R0!, &#123;R4-R11&#125;</span><br><span class="line"></span><br><span class="line">    MSR PSP, R0</span><br><span class="line">    CPSIE I</span><br><span class="line">    BX LR</span><br><span class="line">    ENDP ; ENDP代表函数的结尾</span><br></pre></td></tr></table></figure><p><strong>注意：这里的代码只是逻辑实现，完整的实现请参考下文。</strong></p>    </div></div><h2 id="2-“启动”"><a href="#2-“启动”" class="headerlink" title="2 “启动”"></a>2 “启动”</h2><p>接下来我们就开始做实验，亲眼看看我们的代码是不是成功了。首先因为我们没写调度器，所以我们需要一个用于触发PendSV的函数<code>OS_Yield()</code>。它通过向中断控制及状态寄存器ICSR（地址：<code>0xE000_ED04</code>）的<code>Bit[28]</code>写入1来挂起PendSV中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OS_Yield</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置第 28 位 (PENDSVSET)，触发 PendSV 异常</span></span><br><span class="line">    (*(<span class="keyword">volatile</span> <span class="type">uint32_t</span> *)<span class="number">0xE000ED04</span>) = (<span class="number">1</span> &lt;&lt; <span class="number">28</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指令同步</span></span><br><span class="line">    __asm(<span class="string">&quot;DSB&quot;</span>); </span><br><span class="line">    __asm(<span class="string">&quot;ISB&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们要写一个开始函数<code>OS_Start()</code>。当我们还没有开始任务调度的时候，<code>CurrentTCB</code>绝对是<code>NULL</code>，即0；而<code>NextTCB</code>指向下一个TCB。所以我们<code>OS_Start()</code>的任务实际上就是<code>PendSV_Handler()</code>的下半部分，只切换不存储。所以我们直接复用<code>PendSV_Handler()</code>，不再写一遍了。<strong>注意：这里很容易错，如果一个不小心寄存器存反了就进HardFault了。所以请仔细核查自己的代码，实在不行就直接复制吧。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PendSV_Handler  PROC  ; PROC代表函数的开头</span><br><span class="line">    CPSID I ; 关中断</span><br><span class="line">    MRS R0, PSP</span><br><span class="line">    ISB ; 指令同步隔离，确保程序生效</span><br><span class="line"></span><br><span class="line">    LDR R2, =CurrentTCB ; 现在R2里存的是CurrentTCB的地址</span><br><span class="line">    LDR R1, [R2] ; 把R2（CurrentTCB）地址中所存的值（就是TCB的首地址，也就是sp变量的地址）存到R1里</span><br><span class="line"></span><br><span class="line">    CMP R1, #0          ; 比较R1和0</span><br><span class="line">    BEQ RestoreContext  ; 如果相等 (Z标志位为1)，直接跳转到恢复上下文部分</span><br><span class="line"></span><br><span class="line">    STMDB R0!, &#123;R4-R11&#125;</span><br><span class="line">    STR R0, [R1] ; 把现在的R0（也就是PSP最终指向的地址）存到R1指向的地址（也就是存进sp变量）</span><br><span class="line"></span><br><span class="line">RestoreContext</span><br><span class="line">    LDR R2, =NextTCB ; 现在R2里存的是NextTCB的地址</span><br><span class="line">    LDR R3, =CurrentTCB ; 现在R3里存的是CurrentTCB的地址</span><br><span class="line">    LDR R1, [R2] ; 把R2（NextTCB）地址中所存的值存到R1里</span><br><span class="line">    STR R1, [R3] ; 把R1（NextTCB的sp变量）存到CurrentTCB的地址所对应的内存中，现在CurrentTCB已经是新的任务了</span><br><span class="line">    LDR R0, [R1] ; 从R1（NextTCB的sp变量）所对应的内存中读取NextTCB（实际上就是CurrentTCB）的sp变量到R0</span><br><span class="line">    LDMIA R0!, &#123;R4-R11&#125;</span><br><span class="line">    MSR PSP, R0</span><br><span class="line">    ORR LR, LR, #0x04   ; 将LR的第2位置1，返回时使用PSP</span><br><span class="line">    CPSIE I</span><br><span class="line">    BX LR</span><br><span class="line">    ENDP</span><br><span class="line"></span><br><span class="line">OS_Start PROC</span><br><span class="line"></span><br><span class="line">    ; 1. 设置PendSV的优先级为最低(0xFF)</span><br><span class="line">    ; 这一步我们在C语言中做</span><br><span class="line">    </span><br><span class="line">    ; 2. 触发PendSV，这里实际上就是我们的OS_Yield函数</span><br><span class="line">    LDR R0, =0xE000ED04 ; ICSR寄存器地址</span><br><span class="line">    LDR R1, =0x10000000 ; 第28位是PENDSVSET</span><br><span class="line">    STR R1, [R0]        ; 写1触发PendSV</span><br><span class="line"></span><br><span class="line">    ; 3. 开中断 (防止之前被关了)</span><br><span class="line">    CPSIE I</span><br><span class="line"></span><br><span class="line">    ; 4. 死循环 (理论上永远不会执行到这里，因为PendSV会立即抢占并切换走)</span><br><span class="line">    B .                 </span><br><span class="line">    </span><br><span class="line">    ENDP</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>main.c</code>里这么写（不要忘记在<code>main</code>函数之前定义任务的TCB和任务栈数组，还有<code>CurrentTCB</code>和<code>NextTCB</code>两个<code>OS_TCB*</code>指针）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 设置 PendSV 优先级为最低 (0xFF)</span></span><br><span class="line">NVIC_SetPriority(PendSV_IRQn, <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 关键初始化</span></span><br><span class="line">Task1TCB.stackPtr = OS_StackInit(Task1, Task1stack, <span class="number">128</span>);</span><br><span class="line">Task2TCB.stackPtr = OS_StackInit(Task2, Task2stack, <span class="number">128</span>);</span><br><span class="line">CurrentTCB = <span class="number">0</span>;       <span class="comment">// 必须设为NULL，告诉汇编这是第一次</span></span><br><span class="line">NextTCB = &amp;Task1TCB; <span class="comment">// 告诉 OS 第一个任务是谁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 启动！</span></span><br><span class="line">OS_Start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// 理论上永远不会运行到这里了</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里的<code>Task1</code>和<code>Task2</code>函数就这么写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> count1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> count2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    count1++;</span><br><span class="line">    NextTCB = &amp;Task2TCB; <span class="comment">// 没有调度器的权宜之计</span></span><br><span class="line">    OS_Yield();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    count2++;</span><br><span class="line">    NextTCB = &amp;Task1TCB;</span><br><span class="line">    OS_Yield();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是插板子调试了。我们可以使用第三期类似的方法，打开Watch Windows，输入<code>count1</code>和<code>count2</code>，如果程序运行正常，它们的值应该飞速增大且最多相差1。</p><p><img src="https://pic1.imgdb.cn/item/693ffe3b4a4e4213d007ea30.png"></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p><strong>我们已经啃下了路线上最难啃的骨头，也许没有之一！</strong> 后面的代码大多是逻辑层面的C语言编程，主要考察的是设计架构和算法编写能力，会轻松很多。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Build Your Own RTOS 系列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Build Your Own RTOS Part3：初始化栈</title>
      <link href="/2025/12/13/2025-12-13-RTOS3/"/>
      <url>/2025/12/13/2025-12-13-RTOS3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Build Your Own RTOS 系列文章</strong>：</p><ol><li><a href="/2025/12/10/2025-12-10-RTOS1/" title="Build Your Own RTOS Part1：理解M3架构的寄存器">理解M3架构</a></li><li><a href="/2025/12/12/2025-12-12-RTOS2/" title="Build Your Own RTOS Part2：硬件自动压栈">硬件自动压栈</a></li><li><strong>当前阅读：初始化栈</strong></li><li><a href="/2025/12/15/2025-12-15-RTOS4/" title="Build Your Own RTOS Part4：PendSV">PendSV</a></li></ol></blockquote><h2 id="1-创建任务"><a href="#1-创建任务" class="headerlink" title="1 创建任务"></a>1 创建任务</h2><p>我们都知道，使用RTOS时要先初始化任务。当任务还没有被执行时，即它没有任何历史记录时，CPU怎么知道应该从哪里开始执行呢？</p><p>这就是我们要做的工作：初始化任务就是初始化栈，即通过手动填充栈，制造一个“假象”，让 CPU 认为这个任务之前正在运行并被中断了。当下一次调度发生时，CPU 就能“恢复”到任务的入口函数。</p><p>涉及到硬件的底层知识基础在前两期中已经讲的差不多了，本期我们聚焦于两个软件设计上的重点：任务控制块（Task Control Block, TCB）和栈初始化函数<code>OS_StackInit()</code>。</p><h2 id="2-任务控制块"><a href="#2-任务控制块" class="headerlink" title="2 任务控制块"></a>2 任务控制块</h2><p>我们已经知道，CPU没有记忆，记忆都放在寄存器里。为了给每一个任务都分配特定的记忆，我们就需要任务控制块。在代码中，任务控制块就是一个简单的结构体。</p><p>既然我们已经知道任务控制块的作用，那结构体里面有什么内容也就很清晰了：</p><ol><li>最重要的东西：SP指针。这是显而易见的，任务控制块中必须有的东西，否则上下文就无法恢复了。值得一提的是，我们通常把这个SP指针放在结构体的第一位。这是因为当任务切换时，最紧急的事情就是先去栈里面找寄存器的值，让他们出栈恢复现场。如果SP指针放在第一位，我们就可以使用类似<code>LR R0, [R1]</code>的语句直接读出SP的值，不需要<strong>计算偏移量</strong>。这样一来，CPU也不需要计算。而且，不管你在SP的后面添加什么东西，都不需要改动这段读取代码，也方便了你自己。</li><li>任务链表指针：只有定义了上下家是谁，OS才能把任务都串起来。</li><li>任务状态：只需看一眼，OS就能知道这个任务是“准备好了”，还是“睡眠中”，还是“挂起了”。</li><li>优先级：同样只要一眼，OS就知道哪个任务要排在前面。</li><li>任务名字。</li></ol><p>所以，我们的代码应该会是下面这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> *stackPtr; <span class="comment">// 【第一位】SP指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span> *<span class="title">next</span>;</span> <span class="comment">// 下一个任务是谁</span></span><br><span class="line">    <span class="type">uint32_t</span> state;                <span class="comment">// 现在的状态</span></span><br><span class="line">    <span class="type">uint32_t</span> priority;             <span class="comment">// 优先级</span></span><br><span class="line">    <span class="type">char</span> *name;                    <span class="comment">// 任务名字</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 可能还有别的，但上面这些最重要</span></span><br><span class="line">&#125; OS_TCB;</span><br></pre></td></tr></table></figure><p>当然，现在我们不用管那么多，TCB里面只放一个sp就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in os_core.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task_Control_Block</span> &#123;</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint32_t</span> *stackPtr;</span><br><span class="line">&#125; OS_TCB;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-栈初始化"><a href="#3-栈初始化" class="headerlink" title="3 栈初始化"></a>3 栈初始化</h2><p>现在我们就准备开始创建我们的任务栈初始化函数。首先我们要明确，这个函数是要接收参数的，但应该接收哪几个参数呢？</p><p>既然是任务的初始化，肯定要知道任务是什么，所以一定要接受<strong>任务函数的入口地址</strong>，也就是我们写好的任务函数的指针。同时，用户会给任务分配<strong>栈大小</strong>，这也是必须要传入的数据。既然已经有了栈大小，我们就要规划栈放在哪里，所以要传入<strong>栈数组的起始地址</strong>。这就是这个函数接受的三个参数。</p><p>接下来我们就开始实现这个函数。还记得中断发生和返回的逻辑吗？我们就要顺着这个逻辑来。</p><ol><li>首先我们要找到栈顶，也就是<code>栈数组的起始地址 + 栈大小</code>。在这里还有一个需要注意的地方，就是要字节对齐，让栈顶指针指向8的倍数。</li><li>然后我们就开始模仿硬件压栈的操作。（还记得压栈的顺序吗？）首先是xPSR，必须要填<code>0x01000000</code>。这是把xPSR的<code>Bit[24]</code>置1，表示<strong>使用Thumb模式</strong>，如果不这么做就会直接进入Hard Fault。</li><li>然后是PC，填入函数入口地址即可，表示“中断”返回后CPU从哪里继续。</li><li>再然后是LR，它应该填入一个“<strong>错误返回函数</strong>”的地址。因为RTOS的任务一般是死循环，是不会返回的，如果返回肯定是哪里出错了，就要跳转到这个地方去处理错误。</li><li>最后是通用寄存器们，通通填0即可。当然我们今天可以填一些特殊的数字（比如给R1填<code>0x11111111</code>），用于调试。</li></ol><p>好了，寄存器就处理完了，现在栈指针就下降到了某个地方。我们要把这个栈指针作为返回值，填到TCB的第一个位置，至此任务初始化结束。</p><p>逻辑讲完了，我们就开始写代码。明确以下几点：任务函数的入口地址是<code>void*</code>类型，栈数组的起始地址是<code>uint32_t*</code>类型，栈大小是<code>uint32_t</code>类型；在实现逻辑中，可以使用<code>*(--sp) = ...</code>给内存地址赋值，模拟<code>PUSH</code>操作。我们在<code>os_cpu.c</code>文件里完成这个函数的实现。</p><p>这里先写一个简单的<code>OS_TaskReturn()</code>函数，供给LR。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OS_TaskReturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class='spoiler collapsed'>    <div class='spoiler-title'>        点击查看答案    </div>    <div class='spoiler-content'>        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span>* <span class="title function_">OS_StackInit</span><span class="params">(<span class="type">void</span>* task_function, <span class="type">uint32_t</span>* stack_init_address, <span class="type">uint32_t</span> stack_depth)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 第一步：找到栈顶 */</span></span><br><span class="line">  <span class="type">uint32_t</span>* sp = stack_init_address + stack_depth;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第二步：字节对齐 */</span></span><br><span class="line">  sp = (<span class="type">uint32_t</span> *)((<span class="type">uint32_t</span>)sp &amp; <span class="number">0xFFFFFFF8</span>); <span class="comment">// 先把sp转成uint32_t，再把最后3位抹成0，最后转成uint32_t *</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第三步：填入数据 */</span></span><br><span class="line">  <span class="comment">/* 硬件区 */</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x01000000</span>; <span class="comment">// xPSR</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)task_function; <span class="comment">// PC</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)OS_TaskReturn; <span class="comment">// LR</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x12121212</span>; <span class="comment">// R12 </span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x03030303</span>; <span class="comment">// R3</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x02020202</span>; <span class="comment">// R2</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x01010101</span>; <span class="comment">// R1</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x00000000</span>; <span class="comment">// R0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 软件区 */</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x11111111</span>; <span class="comment">// R11</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x10101010</span>; <span class="comment">// R10</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x09090909</span>; <span class="comment">// R9</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x08080808</span>; <span class="comment">// R8</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x07070707</span>; <span class="comment">// R7</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x06060606</span>; <span class="comment">// R6</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x05050505</span>; <span class="comment">// R5</span></span><br><span class="line">  *(--sp) = (<span class="type">uint32_t</span>)<span class="number">0x04040404</span>; <span class="comment">// R4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第四步：返回sp */</span></span><br><span class="line">  <span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    </div></div><h2 id="4-整合与验证"><a href="#4-整合与验证" class="headerlink" title="4 整合与验证"></a>4 整合与验证</h2><p>这个阶段中我们将创建两个简单的任务、定义两个TCB变量、定义两个静态数组作为栈。然后我们实现一个简单的错误返回函数供给LR，最后调试。</p><p>首先，在<code>main.c</code>中声明一个结构体<code>OS_TCB Task1TCB;</code>：</p><p>然后定义一个数组，<code>uint32_t Task1stack[128]</code>，分配给这个任务。</p><p>最后我们定义一个简单的任务函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Task1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>main</code>函数里，我们调用写好的函数：<code>Task1TCB.stackPtr = OS_StackInit(Task1, Task1stack, 128);</code>。注意要在这一行打断点，因为我们没写调度器，运行下去可能有问题。</p><p><a href="https://imgchr.com/i/pZMNDSS"><img src="https://s41.ax1x.com/2025/12/13/pZMNDSS.png" alt="pZMNDSS.png"></a></p><p>在菜单栏打开Watch Windows，然后在<code>&lt;Enter expression&gt;</code>中输入刚刚定义的栈数组，就可以找到这个数组<strong>头</strong>对应的地址。然后+200（16进制的512），在这个地址附近找就可以了。（因为我们内存对齐的原因，可能不会精确的在头地址+200处开始存储）</p><p><a href="https://imgchr.com/i/pZMNwJf"><img src="https://s41.ax1x.com/2025/12/13/pZMNwJf.png" alt="pZMNwJf.png"></a></p><div style="text-align: center;">    <em>可以看到我们储存的数据</em></div><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>好了，我们已经解决了路线上的第一个大难点，理解了任务控制块存在的意义、实现了<code>OS_StackInit()</code>函数。下期我们将构造RTOS的心脏<code>PendSV_Handler</code>，是我们路线上的第二个大难点。加油！</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Build Your Own RTOS 系列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Build Your Own RTOS Part2：硬件自动压栈</title>
      <link href="/2025/12/12/2025-12-12-RTOS2/"/>
      <url>/2025/12/12/2025-12-12-RTOS2/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Build Your Own RTOS 系列文章</strong>：</p><ol><li><a href="/2025/12/10/2025-12-10-RTOS1/" title="Build Your Own RTOS Part1：理解M3架构的寄存器">理解M3架构</a></li><li><strong>当前阅读：硬件自动压栈</strong></li><li><a href="/2025/12/13/2025-12-13-RTOS3/" title="Build Your Own RTOS Part3：初始化栈">初始化栈</a></li><li><a href="/2025/12/15/2025-12-15-RTOS4/" title="Build Your Own RTOS Part4：PendSV">PendSV</a></li></ol></blockquote><h2 id="1-“保存现场”"><a href="#1-“保存现场”" class="headerlink" title="1 “保存现场”"></a>1 “保存现场”</h2><p>在上一篇中，我们已经讲解了中断发生时，硬件自动进行的操作以及我们需要执行的操作。但我们还没有亲眼见证过硬件的动作，这一次我们将设计一个中断并触发它，看看硬件究竟会做些什么。</p><h3 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h3><p>由于我们使用CubeMX自动生成文件，代码里已经设定好了时钟树和SysTick。我们进入<code>stm32f1xx_it.c</code>文件寻找一下<code>SysTick_Handler()</code>，然后将其修改成这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN SysTick_IRQn 0 */</span></span><br><span class="line">  __NOP();</span><br><span class="line">  <span class="comment">/* USER CODE END SysTick_IRQn 0 */</span></span><br><span class="line">  <span class="comment">//HAL_IncTick();</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN SysTick_IRQn 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END SysTick_IRQn 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__NOP()</code>是一个宏，代表空指令，在这里设置一个断点（Keil中不允许对空行打断点）。然后我们注释掉<code>HAL_IncTick()</code>，先不管HAL库的SysTick逻辑。在主函数里的<code>HAL_Init()</code>函数中，会自动初始化SysTick，所以我们可以直接观察这个中断。</p><p>这一次我们同样创建一个函数<code>void set_registers()</code>，它的目的和上次“伪造现场”的目的类似，但是这一次我们不填充R4-R11，而是填充R0-R3。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        点击查看答案    </div>    <div class='spoiler-content'>        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">void</span> <span class="title function_">set_registers</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">  MOV R0, #<span class="number">0X11111111</span></span><br><span class="line">  MOV R1, #<span class="number">0X22222222</span></span><br><span class="line">  MOV R2, #<span class="number">0X33333333</span></span><br><span class="line">  MOV R3, #<span class="number">0X44444444</span></span><br><span class="line"></span><br><span class="line">  BX LR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    </div></div><p>然后我们回到<code>main.c</code>中，在<code>main</code>函数的<code>while(1)</code>循环里调用<code>set_registers()</code>，调试运行等待程序碰到断点。</p><h3 id="1-2-观察现象"><a href="#1-2-观察现象" class="headerlink" title="1.2 观察现象"></a>1.2 观察现象</h3><p><img src="https://pic1.imgdb.cn/item/693bfde1eb1155844d20fef9.png"></p><p>我们看到图中，SP对应的内存地址的确整齐的排列好了我们伪造的数据。这证明了：</p><ol><li>中断的确发生了。</li><li>中断发生时，硬件会自动将R0-R3等寄存器压入栈中。</li></ol><p>然后我们再看看<code>0x44444444</code>后面都有些什么。</p><p><img src="https://pic1.imgdb.cn/item/693c0134eb1155844d20ffb4.png"></p><p><img src="https://pic1.imgdb.cn/item/693c013feb1155844d20ffb5.png"></p><p>它们分别是（小端序）：</p><ul><li><p><code>00 0F 00 00</code>：这就是R12的值，只不过在内存里翻过来了。</p></li><li><p><code>B9 0A 00 08</code>：这是LR的值(<code>0x08000AB9</code>)，他代表了中断结束后，程序要回到的地址。</p><p>  <img src="https://pic1.imgdb.cn/item/693c0208fac5ef130364dc32.png"></p><p>  图中的<code>0x08000AB8</code>就是<code>while(1)</code>。这说明程序马上要回到循环中。（还记得为什么LR的值和实际地址差1吗？）</p></li><li><p><code>58 01 00 08</code>：这是PC的值，也就是被打断点的<code>__NOP()</code>的地址。</p></li><li><p><code>00 00 00 61</code>：这是xPSR的值。是状态寄存器在<strong>进入中断前</strong>的状态。</p></li></ul><p>那么，寄存器窗口的值为什么会与栈中的数据不一样呢？</p><p>我们一个个来看：</p><ul><li>寄存器中LR(<code>0xFFFFFFF9</code>)：这其实是<strong>EXC_RETURN</strong>（异常返回码）一旦进入中断，硬件会自动把LR寄存器改成这个特殊值。</li><li>寄存器中xPSR(<code>0x6100000F</code>):还记得xPSR的低位代表什么吗？<code>0x0F</code>是十进制的15，代表<strong>SysTick Exception</strong>，说明目前正在处理SysTick中断。</li></ul><p><strong>至此，我们已经通过实验验证了：在触发中断后，硬件会自动将一些寄存器的值压入栈中，且它们的顺序是<code>xPSR</code> -&gt; <code>PC</code> -&gt; <code>LR</code> -&gt; <code>R12</code> -&gt; <code>R3-R0</code></strong>。这非常重要，推荐记在小本本上。</p><p>但于此同时，也引出了第二个问题：虽然我们已经处理好了这些数据，但是中断结束后怎么办？我该如何知道是使用MSP还是PSP？</p><p>这就用到了异常返回码。实际上，当异常返回码进入PC后，就会启动中断返回序列。合法的异常返回码只有三个：</p><ul><li><code>0xFFFF FFF1</code>：返回Handler模式</li><li><code>0xFFFF FFF9</code>：返回线程模式，并使用MSP</li><li><code>0xFFFF FFFD</code>：返回线程模式，并使用PSP</li></ul><p>主程序在线程模式下，使用哪个栈进入了中断，就会以哪个栈退出中断（以异常返回码标志）。</p><h2 id="2-双栈"><a href="#2-双栈" class="headerlink" title="2 双栈"></a>2 双栈</h2><p>我们已经知道，RTOS是使用两个栈的，那我们就来模拟一下使用两个栈。</p><p>我们需要在<code>main</code>函数里，初始化SysTick前，设置PSP寄存器的值为<code>0x20002000</code>(模拟开辟了一个任务栈)，然后将CONTROL寄存器的<code>Bit[1]</code>置1。同样的，我们在<code>main.c</code>中编写一个函数<code>void create_fake_task()</code>来完成。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        点击查看答案    </div>    <div class='spoiler-content'>        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">void</span> <span class="title function_">create_fake_task</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  MOV R0, #<span class="number">0x20002000</span></span><br><span class="line">  MSR PSP, R0</span><br><span class="line">  MOV R0, #<span class="number">2</span></span><br><span class="line">  MSR CONTROL, R0</span><br><span class="line">  ISB  <span class="comment">//指令同步隔离，确保程序生效</span></span><br><span class="line">  BX LR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    </div></div><p><img src="https://pic1.imgdb.cn/item/693c1898fac5ef1303655d1c.png"></p><p>我们可以非常清楚的看到，LR的值变成了<code>0xFFFFFFFD</code>，符合我们的预期。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>本期我们承接着上期的内容，完整的看了一遍中断的全流程，对<strong>硬件自动做的</strong>和<strong>软件（我们）需要做的</strong>已经有了明确的了解。下期我们将完成一次真正的 <strong>“任务切换”</strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Build Your Own RTOS 系列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Build Your Own RTOS Part1：理解M3架构的寄存器</title>
      <link href="/2025/12/10/2025-12-10-RTOS1/"/>
      <url>/2025/12/10/2025-12-10-RTOS1/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Build Your Own RTOS 系列文章</strong>：</p><ol><li><strong>当前阅读：理解M3架构</strong></li><li><a href="/2025/12/12/2025-12-12-RTOS2/" title="Build Your Own RTOS Part2：硬件自动压栈">硬件自动压栈</a></li><li><a href="/2025/12/13/2025-12-13-RTOS3/" title="Build Your Own RTOS Part3：初始化栈">初始化栈</a></li><li><a href="/2025/12/15/2025-12-15-RTOS4/" title="Build Your Own RTOS Part4：PendSV">PendSV</a></li></ol></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><strong>懂一个东西的最好办法就是自己做一个。</strong> 刚好不管是单片机开发方面还是Linux方面，实时操作系统的原理都是非常重要的，于是我打算开启这个系列，用大约两个月的时间自己动手制作一个基于STM32F103C8T6(Cortex-M3，以后简称CM3)平台的RTOS。这个系列仅作为个人项目记录，只能作为参考，不能当做教程。本系列需要有微机原理、STM32开发和RTOS的前置知识，如果你还没有接触过，请先入门这几个领域后再阅读本系列。</p><p>如果你打算跟随本系列，需要了解以下内容：</p><ul><li>作者使用的编译环境是Keil ARMCC V5.06、使用STM32CubeMX自动生成HAL库的Keil项目文件。</li><li>请一定要在网上下载《Cortex-M3权威指南》（后称《指南》）的pdf作为参考资料，它非常重要。本系列的绝大多数硬件知识是基于这本书整理而成。</li><li>请在<a href="https://github.com/SandOcean-ovo/Build-Your-Own-RTOS%E4%B8%8A%E9%98%85%E8%AF%BBREADME.md%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E5%AE%8C%E6%88%90%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%82">https://github.com/SandOcean-ovo/Build-Your-Own-RTOS上阅读README.md，根据文档中的指令完成项目结构的配置。</a></li></ul><h2 id="1-认识寄存器"><a href="#1-认识寄存器" class="headerlink" title="1 认识寄存器"></a>1 认识寄存器</h2><p>CM3架构的MCU拥有通用寄存器 R0-R15 以及一些特殊功能寄存器。</p><p><img src="https://pic1.imgdb.cn/item/69390d5a6166b8110132870e.png" alt="寄存器表"></p><p><img src="https://pic1.imgdb.cn/item/693923f56166b8110136214e.png" alt="特殊寄存器表"></p><h3 id="1-1-通用寄存器（R0-R12）"><a href="#1-1-通用寄存器（R0-R12）" class="headerlink" title="1.1 通用寄存器（R0-R12）"></a>1.1 通用寄存器（R0-R12）</h3><p>这里简单提一下，根据AAPCS（ARM Architecture Procedure Call Standard，ARM过程调用标准），为了高效率的处理，将R0-R3四个寄存器用于函数传参。（例如C语言中调用<code>add(a, b, c ,d)</code>，这里的<code>a, b, c, d</code>就是参数）</p><p><em>注意：在Thumb-2指令集中，不可以直接<code>MOV</code>一个32位的立即数到寄存器，因为指令长32位，光是一个立即数就把指令占满了，它就无法执行。但是对于某些特殊的立即数，比如小于8位的（<code>0x000000XY</code>），移位后的小于8位的（<code>0x000XY000</code>），模式复制（<code>0xXYXYXYXY</code> 、<code>0x00XY00XY</code>、<code>0xXY00XY00</code>），编译器会将其优化，于是就可以把32位的数塞进指令里。在这期及以后，你可能会看到我使用<code>MOV</code>将一个32位数移到寄存器里，但那些都是利用了ARM的这个编码特性，是合法的。但对于绝大多数的立即数，使用<code>MOV</code>是非法的，所以我们使用伪指令<code>LDR &#123;寄存器&#125; =0x12345678</code>，它会在内存的一个特定位置读到这个数据并存到寄存器中。</em></p><h3 id="1-2-栈指针（Stack-Point，R13）"><a href="#1-2-栈指针（Stack-Point，R13）" class="headerlink" title="1.2 栈指针（Stack Point，R13）"></a>1.2 栈指针（Stack Point，R13）</h3><p>这是我们设计RTOS的基础。（由于历史遗留问题，许多中文资料将 Stack Point 翻译成“堆栈指针”，这里纠正这个错误，使用正确的“栈指针”）</p><p>在 CM3 处理器内核中共有两个栈指针，于是也就支持两个栈。当引用 R13（或写作 SP）时，引用到的是当前正在使用的那一个，另一个必须用特殊的指令来访问（MRS,MSR指令）。这两个栈指针分别是：</p><ul><li><strong>主栈指针（MSP）</strong>：这是默认的堆栈指针，它由 OS 内核、异常服务例程以及所有需要特权访问的应用程序代码来使用。 </li><li><strong>进程栈指针（PSP）</strong>：用于常规的应用程序代码（不处于异常服用例程中时）。</li></ul><p><strong>注意：</strong> CM3内部确实有两个寄存器MSP和PSP，CPU会根据特殊寄存器CONTROL的状态，将其中一个映射（Banked）到R13上，这就是你必须用MRS、MSR指令访问另一个的原因。</p><p><strong>两个栈指针带来什么好处？</strong></p><ol><li>如果只有一个栈指针，内核和用户程序就只能共用一个栈指针，虽然可以用，但做什么事都得战战兢兢地，只要做错一件事程序就极有可能跑飞。有了两个栈指针，内核和用户程序就内分开，即使用户程序跑崩了，也不至于把整个系统都搞坏，只要在内核把这个跑崩的用户程序“开除”就可以了。</li><li>操作系统的一个基本原理是“任务调度”，有两个栈指针，内核就不会干扰到上下文切换。</li></ol><h4 id="1-2-1-栈的操作模式：满减栈"><a href="#1-2-1-栈的操作模式：满减栈" class="headerlink" title="1.2.1 栈的操作模式：满减栈"></a>1.2.1 栈的操作模式：满减栈</h4><p>ARM架构支持多种栈操作模式，但是CM3默认使用<strong>满减栈</strong>。</p><ul><li>“满”：SP指针总是指向最后一个被压入栈的数据（即栈顶是有数据的），而不是空的可用槽位。</li><li>“减”：堆栈向低地址方向生长。</li></ul><p>这意味着：</p><ul><li>压栈（PUSH）时：SP 先自减（SP &#x3D; SP - 4），然后将数据存入 SP 指向的地址。</li><li>出栈（POP）时：先读出 SP 指向的数据，然后 SP 自增（SP &#x3D; SP + 4）。</li></ul><p>这就是为什么在后面的实验中，你会看到随着数据的压入，SP 的地址值反而越来越小。</p><h3 id="1-3-连接寄存器（Linking-Register，R14）"><a href="#1-3-连接寄存器（Linking-Register，R14）" class="headerlink" title="1.3 连接寄存器（Linking Register，R14）"></a>1.3 连接寄存器（Linking Register，R14）</h3><p>LR 用于在调用子程序时存储返回地址。它主要解决的是程序在调用“函数”结束后，返回到哪里的问题。</p><p>例如使用汇编指令<code>BL funtion</code>（分支并链接子程序<code>function</code>）时，硬件会自动把下一个命令的地址填入LR，当子程序结束后（使用<code>BX LR</code>返回），通过阅读LR的值来返回原地址继续执行任务。</p><p>如果需要嵌套函数调用，则可以使用<code>PUSH &#123;LR&#125;</code>将LR的值压入堆栈，结束后使用<code>POP &#123;PC&#125;</code>再拿出来即可。</p><h3 id="1-4-程序计数器（Program-Counter，R15）"><a href="#1-4-程序计数器（Program-Counter，R15）" class="headerlink" title="1.4 程序计数器（Program Counter，R15）"></a>1.4 程序计数器（Program Counter，R15）</h3><p><strong>PC 是用于追踪程序流的指针，由于流水线的存在，它总是指向当前执行位置的“前方”。</strong></p><p>比如有这样的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1000: MOV R0, PC ; R0 = 0x1004</span><br></pre></td></tr></table></figure><p>即：读PC的值会返回当前指令地址 +4。</p><p>由于指令集的原因，<strong>加载到 PC 的数值必须是奇数（即 LSB&#x3D;1）。</strong> 通俗的讲，你不能向PC写入偶数，否则会进入异常。但是向PC写入奇数后，PC会自动将其-1。</p><h3 id="1-5-特殊功能寄存器组"><a href="#1-5-特殊功能寄存器组" class="headerlink" title="1.5 特殊功能寄存器组"></a>1.5 特殊功能寄存器组</h3><p>CM3的特殊功能寄存器包括：</p><ol><li>程序状态寄存器组（xPSR）</li><li>中断屏蔽寄存器组（PRIMASK, FAULTMASK,以及 BASEPRI）</li><li>控制寄存器（CONTROL）</li></ol><p>它们只能被特定的指令<code>MRS/MSR</code>访问，也没有与之相关联的访问地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MRS &lt;gp_reg&gt;, &lt;special_reg&gt; ;读特殊功能寄存器的值到通用寄存器</span><br><span class="line">MSR &lt;special_reg&gt;, &lt;gp_reg&gt; ;写通用寄存器的值到特殊功能寄存器</span><br></pre></td></tr></table></figure><h4 id="1-5-1-程序状态寄存器组"><a href="#1-5-1-程序状态寄存器组" class="headerlink" title="1.5.1 程序状态寄存器组"></a>1.5.1 程序状态寄存器组</h4><p>程序状态寄存器在其内部又被分为三个子状态寄存器：</p><ul><li>应用程序 PSR（APSR）</li><li>中断号 PSR（IPSR）</li><li>执行 PSR（EPSR）</li></ul><p>所以，通过读取PSR的不同位来获取各项信息。</p><p><img src="https://pic1.imgdb.cn/item/69394dbe07135a7c195f4fe5.png" alt="PSR"></p><p>比较需要了解的就是，高位（Bit27 - Bit31）是APSR，用于数学运算后标志负数、零、借位等信息；低位（Bit0 - Bit8）是IPSR，存储了异常编号；中间位是EPSR，除了<code>Bit[24]</code>的T位外（我们以后会讲），通常不需要改动。</p><h4 id="1-5-2-中断屏蔽寄存器组"><a href="#1-5-2-中断屏蔽寄存器组" class="headerlink" title="1.5.2 中断屏蔽寄存器组"></a>1.5.2 中断屏蔽寄存器组</h4><p>用于控制异常的使能和除能。</p><ul><li>PRIMASK：一个单一比特的寄存器。在它被置1后，就关掉所有可屏蔽的异常，只剩下 NMI（不可屏蔽中断） 和 Hard Fault 可以响应。它的默认值是 0，表示没有关中断。</li><li>FAULTMASK：同样是单一比特。被置1后，除了NMI外的异常均不被响应。它的默认值同样是 0。</li><li>BASEPRI：这个寄存器最多有 9 位（由表达优先级的位数决定）。它定义了被屏蔽优先级的阈值。当它被设成某个值后，所有优先级号大于等于此值的中断都被关闭（优先级号越大，优先级越低）。但若被设成 0，则不关闭任何中断，0 也是默认值。</li></ul><h4 id="1-5-3-控制寄存器"><a href="#1-5-3-控制寄存器" class="headerlink" title="1.5.3 控制寄存器"></a>1.5.3 控制寄存器</h4><p>控制寄存器有两个用途，其一用于定义特权级别，其二用于选择当前使用哪个堆栈指针。由两个比特来行使这两个职能。</p><ul><li><strong>Bit0</strong>：决定当前特权级别，置0时为特权级（Privileged），置1时为用户级（User）。当进入Handler模式时，CPU会无视这个寄存器值，直接进入特权级。仅当在特权级下才有对该位操作的权限，所以一旦进入了用户级，唯一返回特权级的途径就是触发一个中断，再由服务例程改写该位。</li><li><strong>Bit1</strong>：决定栈指针功能的选择。置0时选择MSP（这也是复位后的默认值），置1时选择PSP。在线程或基础级，可以使用 PSP。在 Handler 模式下，只允许使用 MSP，所以此时不得往该位写 1。</li></ul><h2 id="2-操作模式和特权级别"><a href="#2-操作模式和特权级别" class="headerlink" title="2 操作模式和特权级别"></a>2 操作模式和特权级别</h2><p>同样是我们设计RTOS的基础。</p><p><img src="https://pic1.imgdb.cn/item/693954ec07135a7c195fa65d.png" alt="操作模式和特权级别"></p><h3 id="2-1-操作模式"><a href="#2-1-操作模式" class="headerlink" title="2.1 操作模式"></a>2.1 操作模式</h3><p>CM3有两个操作模式：<strong>线程（Thread）模式</strong>和<strong>处理者（Handler）模式</strong>。</p><p>线程模式用于运行普通应用程序的代码，可以使用特权级，也可以使用用户级。复位后，处理器默认进入线程模式</p><p>Handler模式用于运行异常服务例程的代码，包括中断服务程序。它总是特权级的。</p><h3 id="2-2-特权级别"><a href="#2-2-特权级别" class="headerlink" title="2.2 特权级别"></a>2.2 特权级别</h3><p>处理器支持<strong>特权级</strong>和<strong>用户级</strong>两种特权操作。这种分级提供了存储器访问的保护机制，防止普通用户程序意外或恶意地执行涉及系统要害的操作。</p><ol><li>特权级:<ul><li>特权级的程序可以访问所有范围的存储器（如果有存储器保护单元 MPU，则在 MPU 规定的禁地之外）。</li><li>可以执行所有指令。</li><li>处理器在复位后默认以特权级启动。</li></ul></li><li>用户级:<ul><li>一旦进入用户级，程序受到限制，无法访问系统控制空间（SCS），该空间包含配置寄存器组和调试组件的寄存器组。</li><li>用户级代码禁止访问和修改除APSR之外的特殊功能寄存器。如果尝试越权访问 SCS，将触发Fault异常。</li><li>用户级程序不能直接修改 CONTROL 寄存器以返回特权级。唯一返回特权级的途径是通过异常（例如执行系统调用指令 SVC），由异常服务例程接管并完成模式切换。</li></ul></li></ol><h2 id="3-CM3中RTOS的上下文切换"><a href="#3-CM3中RTOS的上下文切换" class="headerlink" title="3 CM3中RTOS的上下文切换"></a>3 CM3中RTOS的上下文切换</h2><p>这是操作系统的最底层逻辑之一。</p><h3 id="3-1-上下文（Context）"><a href="#3-1-上下文（Context）" class="headerlink" title="3.1 上下文（Context）"></a>3.1 上下文（Context）</h3><p>实际上，上下文可以理解成所有16个寄存器+xPSR。如果在一个任务未完成时将它们先分别保存好，然后修改它们，让去完成另一个任务，之后再将它们移回来，CPU就会继续刚刚未完成的任务。</p><h3 id="3-2-如何保存上下文"><a href="#3-2-如何保存上下文" class="headerlink" title="3.2 如何保存上下文"></a>3.2 如何保存上下文</h3><p>在CM3的RTOS里，保存R0-R15不是一次性完成的，而是分成了“自动”和“手动”两部分。RTOS 的任务切换通常发生在<code>PendSV</code>异常（这是 OS 专门用来切换任务的软中断）里。</p><h4 id="3-2-1-硬件自动保存"><a href="#3-2-1-硬件自动保存" class="headerlink" title="3.2.1 硬件自动保存"></a>3.2.1 硬件自动保存</h4><p>当 PendSV 中断发生的一瞬间，CPU会自动把最紧急的东西扔进栈里。</p><p>它们是：<strong>xPSR, PC, LR, R12, R3, R2, R1, R0</strong>，这些是“易失性”的，必须马上保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">高地址  +-------------------+</span><br><span class="line">       |       xPSR        |</span><br><span class="line">       +-------------------+</span><br><span class="line">       |        PC         |  &lt;-- 返回地址 (被中断的那条指令)</span><br><span class="line">       +-------------------+</span><br><span class="line">       |        LR         |  &lt;-- 函数返回</span><br><span class="line">       +-------------------+</span><br><span class="line">       |        R12        |</span><br><span class="line">       +-------------------+</span><br><span class="line">       |        R3         |</span><br><span class="line">       +-------------------+</span><br><span class="line">       |        R2         |</span><br><span class="line">       +-------------------+</span><br><span class="line">       |        R1         |</span><br><span class="line">       +-------------------+</span><br><span class="line">       |        R0         |  &lt;-- 栈顶 (SP 指向这里)</span><br><span class="line">低地址  +-------------------+</span><br></pre></td></tr></table></figure><p>注意：虽然我们常说压栈顺序是 <code>xPSR</code> -&gt; <code>PC</code> -&gt; … -&gt; <code>R0</code>，但由于是“满减栈”，R0最终会位于内存的<strong>最低地址</strong>（也就是当前的SP位置）。这一点在后续的内存取证实验中至关重要。</p><h4 id="3-2-2-软件手动保存"><a href="#3-2-2-软件手动保存" class="headerlink" title="3.2.2 软件手动保存"></a>3.2.2 软件手动保存</h4><p>也就是我们要做的操作，在<code>PendSV</code>中断服务函数里，将其余的<strong>R4-R11</strong>也保存在栈中。</p><h3 id="3-3-核心：切换上下文"><a href="#3-3-核心：切换上下文" class="headerlink" title="3.3 核心：切换上下文"></a>3.3 核心：切换上下文</h3><p>现在所有东西都存完了，我们就开始换“灵魂”（操作SP）：</p><ul><li>保存旧SP： 把当前（任务1）的PSP值，记录任务1的“任务控制块（TCB）”里。</li><li>加载新SP： 从任务2的TCB中，读出任务2上次停下来的PSP值。</li><li>写入SP： 把这个值塞进CPU的PSP寄存器。</li></ul><p>接下来，软件（我们）再手动将任务2的R4-R11出栈，执行中断返回，硬件最后会自动将易失性寄存器出栈，一个上下文切换就做完了。</p><h2 id="4-动手实操"><a href="#4-动手实操" class="headerlink" title="4 动手实操"></a>4 动手实操</h2><p>出于篇幅考虑，本系列不打算过于详细的介绍汇编指令和C语言编程，但是对于特定的代码，会给出必要的注释和解释。</p><h3 id="4-1-A-Hello-World"><a href="#4-1-A-Hello-World" class="headerlink" title="4.1 A Hello-World"></a>4.1 A Hello-World</h3><p>先用一个简单的题目来熟悉一下汇编语言，并验证一下上面的关于AAPCS的知识。</p><p><strong>题目：</strong> 在 <code>main.c</code> 文件中编写一个函数 <code>__asm int asm_add(int a, int b)</code>，并在<code>main</code>函数中调用。进入Debug模式以查看各寄存器的值。</p><p>思考：LR 寄存器里的值指向哪里？执行完加法函数返回后，PC 的值变成了什么？</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        点击查看答案    </div>    <div class='spoiler-content'>        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">int</span> <span class="title function_">asm_add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">  ADD R0, R0, R1 </span><br><span class="line">  BX LR <span class="comment">//思考：为什么要有这一句？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic1.imgdb.cn/item/693a272b6166b8110137b984.png"><br><img src="https://pic1.imgdb.cn/item/693a27636166b8110137bad9.png"></p><p>观察R0、R1寄存器的变化。</p>    </div></div><h3 id="4-2-读取MSP-PSP"><a href="#4-2-读取MSP-PSP" class="headerlink" title="4.2 读取MSP&#x2F;PSP"></a>4.2 读取MSP&#x2F;PSP</h3><p><strong>题目：</strong> 在<code>main.c</code>中编写两个函数<code>__asm uint32_t get_msp_val()</code>和<code>__asm uint32_t get_psp_val()</code>,将MSP&#x2F;PSP的值移至R0并在<code>main</code>函数中调用。进入Debug模式，重点观察R0寄存器的值。</p><p>思考：系统刚复位并在<code>main</code>运行时，PSP 的值应该是多少？和你看到的一样吗？</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        点击查看答案    </div>    <div class='spoiler-content'>        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">uint32_t</span> <span class="title function_">get_msp_val</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  MRS R0, MSP</span><br><span class="line">  BX LR</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__asm <span class="type">uint32_t</span> <span class="title function_">get_psp_val</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  MRS R0, PSP</span><br><span class="line">  BX LR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic1.imgdb.cn/item/693a27e06166b8110137c085.png"></p><div style="text-align: center;">    <em>执行 MRS R0, MSP 前</em></div><p><img src="https://pic1.imgdb.cn/item/693a28076166b8110137c249.png"></p><div style="text-align: center;">    <em>执行后</em></div><p><img src="https://pic1.imgdb.cn/item/693a28dd6166b8110137ca11.png"></p><div style="text-align: center;">    <em>执行 MRS R0, PSP 后</em></div>    </div></div><h3 id="4-3-手动压栈"><a href="#4-3-手动压栈" class="headerlink" title="4.3 手动压栈"></a>4.3 手动压栈</h3><p>简单模拟一下RTOS上下文切换的手动操作过程，将R4到R11压入当前栈（SP 指向的位置）。在<code>main.c</code>中编写一个函数<code>__asm void save_context_test()</code>来完成。</p><p>提示：先读出PSP的值，存到R0中，再将R4和R11压入R0所存的地址中。你可能会用到的指令有<code>MRS</code>和<code>STMDB</code>。（如果还不会用，可以查阅《指南》的第四章）</p><p>使用以下这个函数来伪造数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">void</span> <span class="title function_">setup_fake_environment</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 【造假数据】强行把 R4-R11 填满记号</span></span><br><span class="line">    MOV R4, #<span class="number">0x04040404</span></span><br><span class="line">    MOV R5, #<span class="number">0x05050505</span></span><br><span class="line">    MOV R6, #<span class="number">0x06060606</span></span><br><span class="line">    MOV R7, #<span class="number">0x07070707</span></span><br><span class="line">    MOV R8, #<span class="number">0x08080808</span></span><br><span class="line">    MOV R9, #<span class="number">0x09090909</span></span><br><span class="line">    MOV R10, #<span class="number">0x10101010</span></span><br><span class="line">    MOV R11, #<span class="number">0x11111111</span></span><br><span class="line"></span><br><span class="line">    LDR R0, =<span class="number">0x20001000</span></span><br><span class="line">    MSR PSP, R0</span><br><span class="line"></span><br><span class="line">    BX LR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>main</code>函数里依次调用<code>setup_fake_environment</code>和<code>save_context_test</code>，观察寄存器数据、内存里的数据。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        点击查看答案    </div>    <div class='spoiler-content'>        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">void</span> <span class="title function_">save_context_test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  MRS R0, PSP</span><br><span class="line">  STMDB R0!, &#123;R4-R11&#125;</span><br><span class="line">  BX LR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic1.imgdb.cn/item/693a296c6166b8110137ceec.png"></p><div style="text-align: center;">    <em>执行完 setup_fake_environment 后</em></div><p><img src="https://pic1.imgdb.cn/item/693a29ad6166b8110137d11b.png"></p><p><strong>内存地址<code>0x20001000</code>前，整齐的躺着我们“伪造”的数据。</strong> 我们使用的<code>STMDB</code>是自减，天生带有<code>PUSH</code>的属性，故在这里是内存地址减少的存储。</p>    </div></div><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>本次我们比较深入的理解了和RTOS架构紧密相关的寄存器和操作模式等，为我们理解并设计RTOS的任务切换打下了基础。</p><p>下一次我们将亲手触发中断，看看中断触发时到底会发生什么，以及我们要在<code>PendSV_Handler</code>中做些什么。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Build Your Own RTOS 系列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树莓派：解决 picamera2 在 pyenv 环境下的 ModuleNotFoundError: No module named &#39;libcamera&#39;</title>
      <link href="/2025/12/03/2025-12-03-%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B0%83%E8%AF%951/"/>
      <url>/2025/12/03/2025-12-03-%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B0%83%E8%AF%951/</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派-解决-Pyenv-虚拟环境下-Picamera2-无法加载-libcamera-的问题"><a href="#树莓派-解决-Pyenv-虚拟环境下-Picamera2-无法加载-libcamera-的问题" class="headerlink" title="[树莓派] 解决 Pyenv 虚拟环境下 Picamera2 无法加载 libcamera 的问题"></a>[树莓派] 解决 Pyenv 虚拟环境下 Picamera2 无法加载 libcamera 的问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在使用树莓派进行机器视觉开发时，遇到了一个棘手的环境问题。在使用 <code>pyenv</code> 管理的 Python 环境中运行 <code>picamera2</code> 时，程序无法找到系统级的 <code>libcamera</code> 库。本文记录了从排查到解决的完整过程，希望能帮助遇到同样问题的朋友。</p><h2 id="1-问题复现"><a href="#1-问题复现" class="headerlink" title="1. 问题复现"></a>1. 问题复现</h2><p>在 Raspberry Pi OS 上，使用 <code>pyenv</code> 创建的 Python 环境运行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> picamera2 <span class="keyword">import</span> Picamera2</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">import</span> libcamera</span><br></pre></td></tr></table></figure><p><strong>报错信息：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;camera_test.py&quot;, line 2, in &lt;module&gt;</span><br><span class="line">    from picamera2 import Picamera2, Preview</span><br><span class="line">  File &quot;/path/to/site-packages/picamera2/__init__.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    import libcamera</span><br><span class="line">ModuleNotFoundError: No module named &#x27;libcamera&#x27;</span><br></pre></td></tr></table></figure><h2 id="2-深度解析：为什么会报错？"><a href="#2-深度解析：为什么会报错？" class="headerlink" title="2. 深度解析：为什么会报错？"></a>2. 深度解析：为什么会报错？</h2><p>这个问题的本质是 <strong>Python 环境隔离</strong> 与 <strong>系统级依赖</strong> 之间的冲突。</p><ol><li><strong>libcamera 的特殊性</strong>：<code>libcamera</code> 的 Python 绑定并非通过 <code>pip</code> 安装的标准包，而是通过系统包管理器（<code>apt</code>）安装的（<code>python3-libcamera</code>），它位于系统的 <code>/usr/lib/python3/dist-packages</code> 目录下。</li><li><strong>Pyenv 的隔离机制</strong>：<code>pyenv</code> 安装的 Python 版本（如 3.9.18）是独立编译的，默认无法“看到”系统的 <code>dist-packages</code>。</li><li><strong>错误的虚拟环境基底</strong>：通常我们习惯用 <code>python -m venv</code> 创建虚拟环境。如果当前处于 <code>pyenv</code> 激活状态，这个 <code>python</code> 指向的是 <code>pyenv</code> 的版本，而非系统自带的 <code>/usr/bin/python3</code>。这导致即使加了 <code>--system-site-packages</code> 参数，也无法链接到系统级的 <code>libcamera</code>。</li></ol><h2 id="3-排查与修复实战"><a href="#3-排查与修复实战" class="headerlink" title="3. 排查与修复实战"></a>3. 排查与修复实战</h2><p>为了彻底解决问题，我采用了“自下而上”的验证方法，确保硬件、驱动、系统环境无误后，再修复 Python 环境。</p><h3 id="第一步：验证系统底层（排除硬件问题）"><a href="#第一步：验证系统底层（排除硬件问题）" class="headerlink" title="第一步：验证系统底层（排除硬件问题）"></a>第一步：验证系统底层（排除硬件问题）</h3><p>首先，暂时屏蔽 <code>pyenv</code>，确保使用的是树莓派原生系统环境。</p><ol><li><p><strong>临时清理环境变量</strong>（在当前终端执行）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> PYENV_ROOT</span><br><span class="line"><span class="built_in">export</span> PATH=$(<span class="built_in">echo</span> <span class="variable">$PATH</span> | sed <span class="string">&#x27;s|/home/sandocean/.pyenv/shims:||&#x27;</span> | sed <span class="string">&#x27;s|/home/sandocean/.pyenv/bin:||&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>测试摄像头驱动</strong>：<br>运行 <code>libcamera-hello</code>。如果屏幕出现 5 秒预览，说明硬件和底层驱动正常。</p></li><li><p><strong>验证系统 Python</strong>：<br>使用系统绝对路径的 Python 尝试导入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/python3 -c <span class="string">&quot;import libcamera; print(libcamera)&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>预期结果</strong>：无报错，且打印出模块路径（如 <code>/usr/lib/python3/dist-packages/...</code>）。</p></blockquote></li></ol><h3 id="第二步：创建“混合型”虚拟环境（核心解决方案）"><a href="#第二步：创建“混合型”虚拟环境（核心解决方案）" class="headerlink" title="第二步：创建“混合型”虚拟环境（核心解决方案）"></a>第二步：创建“混合型”虚拟环境（核心解决方案）</h3><p>既然 <code>libcamera</code> 依赖系统环境，我们需要基于<strong>系统 Python</strong> 来创建虚拟环境，并通过参数打通系统包的访问权限。</p><ol><li><p><strong>清理旧环境</strong>：删除之前创建失败的 <code>venv</code> 文件夹。</p></li><li><p><strong>使用绝对路径创建环境</strong>（关键步骤）：<br>不要直接用 <code>python</code>，而是指定 <code>/usr/bin/python3</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设在项目根目录</span></span><br><span class="line">/usr/bin/python3 -m venv venv --system-site-packages</span><br></pre></td></tr></table></figure><p><em>注意：<code>--system-site-packages</code> 参数是必须的，它允许虚拟环境访问系统的 <code>apt</code> 安装包。</em></p></li><li><p><strong>激活并验证</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次验证导入</span></span><br><span class="line">python -c <span class="string">&quot;import libcamera; print(&#x27;Success!&#x27;)&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="4-总结与避坑"><a href="#4-总结与避坑" class="headerlink" title="4. 总结与避坑"></a>4. 总结与避坑</h2><p>解决此问题的关键在于理解：<strong><code>picamera2</code> 和 <code>libcamera</code> 强依赖于树莓派系统的 apt 包</strong>。</p><ul><li>❌ <strong>不要</strong> 试图在纯净的 <code>pyenv</code> 版本（如 3.10.x）中通过 pip 安装 libcamera（源里没有这个包）。</li><li>✅ <strong>正确做法</strong>：使用系统自带的 <code>/usr/bin/python3</code> 作为基底创建虚拟环境，并开启 <code>--system-site-packages</code>。</li></ul><p>这样既能享受虚拟环境带来的包管理便利，又能顺利调用系统级的硬件驱动库。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>扪心自问（二）</title>
      <link href="/2025/08/29/2025-08-29-%E6%89%AA%E5%BF%83%E8%87%AA%E9%97%AE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/08/29/2025-08-29-%E6%89%AA%E5%BF%83%E8%87%AA%E9%97%AE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，你的权限好像不够哦" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="822f013e6790aae032f06a434fdedd20c5f8e9537790f4356817d393731cfcd1">25f19230aea40b808fa4be3db405080d1238ce1f70b38fbc67a06c1ab3d9f751c49e7bea03225b33451b0ef4c589530171534e16a5061e27759b8a7a7b08f82abee130eba8eb74a09aede624a3a1b52bfa0c5e80039110227f01ddf12219f39317b4392489d9cfdccb489191af297a5f7716a5c121f6c47ac5f9b6301a836b0c4226bf2d315ab2dc2cacc442632bccdb66af344ccb1745b3b969076a3992e99e3417b73b65d1dbee5049568926b99d3e9d2055fd58833a04753f6a36cd722b4bf00808daab49f28fa9111e621c653ecfe22e85718b082e0e27973058487f41fd61bc3733e957a53085fdb02a607f21c7470ff2d950021523d90c13d800f3d33d2c724e7f2f8966b73131540be75a9f47c75cfec8016e3e9c28861cc5a6e02a84367d328a8a065407cdabe075663ebab1b6a1a4c7e8abfed43249cf083b305a03364f9d3c30ad1c3ff9c4011522c87575f49b9741a270c1a572d2186a5118c3ccabaf3742541a9f85138b8dea57a863930a338275afb0160409a17388ae2e0b75613b0cac85481a92d383bb0d5bb6f3bdb404eec13c294e53509c75e923033af8a18759c4ad598a25fb6d6377668bbb0716aa31d991267e7d0c616fcf2e5d56c23b3584b07b8b554babe4c7a3b823cba48ad2433c8ec89120ed1f4fc89e8ec9f89e255d3b04cb7306a36c2df0411243b25e3fd9dbf2e857960f862009d8f8a2ee5c4a99071f647c4feaacc621f713120dd437bc62a7e771e3bf641dc0b1051b336a8a73a60f71eb77e34cbf0c9d1673d6baadf6163b083f15bf6502cf6b7af92224344b244ad62d0091082daf8f25b7e597b33364aa0ed66b92b8bd514e658098f8486f38bdc1271779fee1949eb038750969dd3ebbf9e19a2a11c5cd4eb00d21a02620cab49b3efd395a83590116ba3c2f20bbfd147a736e0ca2a043c08778464fb65212a018eb2ef98845d764246957304f03d368ad36bc31777b92a697a4af6375b9a41ea2c8d75b68ef9ef2cf7787b6ab8a117249d555bcad5fc3b4634305ab94947b5e7f876f42fc93d24a673f1b6057943ebd144d4a6f7c2837f1bc729446efe7c0f6d2d496afcba09e843c45f3a89a5979c73146f3ad6c4aaaee8278a5872ad64a2c8bdee1ace07b8e8f7b59ac72bbb591f9583864aa32fbc59d0c11b9fb7baf7cd9df6b4ea567aa84386fcb7b3a748ed38dfe1ae8b664d499cb44356ab6371b321bb30a5ac01be02cca5e820e52f52bcd79853b1bf2409296aa80d3af7a29d0e51644a5e7c1cf0a013f39cb544ff76dee66b384e0970be7696b56309a582e51e2d130b7e0e1145b86933b946db173d413249e7495339f34b5d2c1712b84121fc2f3cce4cbc68a8a18f955126d39b6a71cfe4aee3240058addeb24904959874ba0e5647d915ffa5e8c9aa10e166af08bbc4f1832ddd1cdfc511e9029f6d04a90d628abb4a26be20e83a781b9a9d3d26545926d362b7f9a69dde8404ad7ce499e74bede17b4f0dad8add4e97a57f2718920e821e1ee41c4a30e5db57fa38ab1b9ce3e3f8824b790c5400b1a20e5143593b08f8cbdb9478bb1956f38abd905f12b855cee0157224909316292bb663e3755ef905a2579983b670ece213550b49975a9d3791e243dbce14eaa544f9ffa3dd89b42ea556f414ca6d4d5be5424ef2af23fa325927f3e65a05736b313897b64b9ada45382f66661897c1e8b5509dbd20be9ff5e257b8b02721a669ed2a6897e263d68534819ae3108fb89b9ccf59bfc248e5ca011c6a1a4e4f41f1f8cfe56efb1dcc7db4d197bdc22bdccc783e96a35e98274a755adaa3598c4aa59b87a02bc1414e19b65e24daacd5fade4dd990a3599969f379e19199a86da99e797dc22a48448af9691d6ab380c52f8fd8a5c52e5bce2e09f5102e2a115ad01a750647b30b5ea9c1277b8aeb50ee46879d904b5cbb4c7a55072393cd6d87cf96ca04f985ff6298203ae0b41371299b81a8a4e63b79ddd71ddb7233fcbb1330e8347ee666cd8a8c63ee975b9795e1c2b9dcb122a167086f8826a635ee8407de8434469fd549c82847be4fcdbcb64442524476d87703f6df4260d7062083ae1bee8717052f6c2ec147f0f0e56832c01909415276865d9be39d8ee61e402446e2febfd49679635d00f11d39e3acfa89516f0cae0b1f342fb9555f75564226c5cfbfce32256c13d9046a8fd8d2a279e60de39561da724dab0a55be07e40b8e63bce45e6c644782de260e8d65933653d6eea45284cf75fde4f2a3b1450e1e0d6966c5d9d9ceb94bc635a069d93931ba3a66adc3dcc5db5ffede70b2c84011516ba34ece79c82a33a5f79128b0b01e426a753d1b5085c3bb963db9073205ec75b8aab7e04cbbaff098e219277f36147bbec763dd04432c3eed282417cbec4b5c802170487ea3233d0557d0a0cdbbbb19f8ff40bb48a3faf3b36c8225544d174ae7ba1268627ca016153704d8ca89017fcd21a1c9e3be192f020d46d8ea9305acbb2e74e391b45aec32486510e65062011cf80eeee2460f241d97429adaade292b34099c9df9aa9d0182f662112f04e544fc17a5920cac5604577648e341ff93a7d7a7dd716c585b2d7d424a48e68b9d6f9f6e9ab91a3682b8a4bb6fb7cb12cb8bca7250305d39ee6b1f138cd87b09d5f7bd8a71a07a63554409c559864c4a851cbebd92c32b2f61c7b42b274a7303f73dd06f5b63219ebd49be80e13cbd344594211d186aac9529d376ddcd231c3c57f0a4093d6ab3a028284d9518efa7fbf4638d679bc7e3745f6deddbe258e254c7e12d83200b5b767e851ca2c85f2f2d29bc6777d2fddacc49eccb88bfdf17b0409d95da714eb3eb0f04796faa6854eb2031a982d4ae932854d21cb71b703110d1ff4d179b0453d49f159614ba618029e4e417300b76dce11fb5f1f0d86d4ed0b31a92cb9385fce08c8d32093a808e77bc42e4dfa290fa8e14ecf310587e27df678b09805dafa05b876981b98b1e4b6d36550325f52de57ffbd049bd19ed670b8447dcaf256e71d3e36dc18fd9bda45602756c958a25eea7827df77be707bd60f3bfddbc04c7a9e1f1a1b3aa4f7ce40671bfd93d92cc23b937e44f1a7063560d503692bc69ce9909595ddcfae374f4dbda154c08e936e14cb99b558918d0eda0dfce7f09022991adc4d05100bd87bd6004b5d647ad9c8a5f00adc369933d0e751ae8683b96b7b8cef1710582523fbdcd07af53a3d22579a07ac70cb8a95d72d61adba4713d5d71c1358e8ae8225e03f658dfb27179f6837794934ce3619bbeeaa8d1601e185991e1857100aae6fdd5a4eb421d36c058972af76d0a4ad9f0b0b91cf4b0071cbcd3a73cffcc9c5eef1d8ad23c0e6e7b0ee4a3c001aebc69d8e140dd1feb4226dd595b8d5f188295811c9231654ed180c2d63c7376ad1e1c38d44ed409ccafd7c8e95daf434554a650929cf4f4cd94167279f3afd9d273c039843fe010b83359964a011f08070c140df9523d57cc5ed1838a2c7b7359ee18ce17514c806cec9c4512122ffebc2622c8dfa03928a85089a55a8d517894120526753e065b9057e21b2e679bd435361f6768c53d708087ed4fdbdc3f62517d8c018a875bf96a1b89552927482905f6c77207e8cd81fa4b9151b0c17d9b675e90986338b365ede27c4ad052182278102f91a0b7c026e38ce609fe8846de7e5d8b3d9be3d0b39166a64fdfac09651a8a73366effe87857ec8f514f02b0d96cb13e29803cee0e111f5469ca5abb549e266f0d7ec7e11ba99c0f2be2e1ea352e769c15804ccc7dc812a8fb2d818a3dbbf8b86c7304478f256ec4115ac98255dbebea976146331f7082bf41f23750654d0a0f0080ba570a5f5869a25284e18e45fd8d6b60628f9eeaab6870efa5c53963ee36b83f4ee525a13fccfb0781f0552aeac35849b288fa6a47444d24400de7f097a8923e7e1269d57fa4ab91713676b6769092378f624e4a23ca93dc2af96b21b3202beb26314dc9689fa4eeaedcca9a5e84a2c840457d7f8ff5af060147259d7b6830076f9781a39c81f800f3d29cb3fb8620c79983197a6b28be6e16ff79c2f95bfec5bbf12fef5af14b103e08080f7d842743c65fd6577654f085aef47dfa8b089409958087880f41db36598852e2dcb4911af67a875fb2557f2f2d36d529a708f1d7a95b48b1f06037d7306da2fdab1288de1043073402e13a894e62349becc45ad7424acf8000cb579a2090300bed89ccb1af22697f4a0752cbe56f55917d02b108d342de3177173f621d344f44360df303cd7a4f75be18eaba52e150e18bad347a7022b7738beb7cd79cf831529af7e5523a4d36f0248c2f5fa7d3e6d142014c5e7cc1312fdc2af1b73ef8e83295720f30a14e2b69633d182e4a02861dfd7a67578fa5cfc30a5cd70deabacfcfad62193790e4735c6af14ab3750c47959d88f432dd80e9329f6df08acc68c7a77687e6e0eb55f3b4dc7ff11046e5b16bf255e5eaea57a3961f373bb68fe18a284b7fd557a2aa829ad7321c229639c439b5b75bd24d9de6f057696645b85d625cd3d8b037df06fd781f8b60e47b1f6868ed8c566dfbff8036ba51cda939225f030ca101f6bbbc366db76d7d5b06097fb5c1847f5d3471567c318a4733eb18a0977f163518b53de87b9ad128dd0e16849fbcd3243b461b173e97fbe94f321a55e35b14d5a14c8e7b709d4c7f5e1042a9e1d444ba05f47ab833c02a11680d17c08e38df1d0da186922e67f18bfef64690a5e937a72aa78b3b6679a9b42b6b00422971d3f6481a8e87e7846f866705f4e73bd4ca132a0dd15cf396fd08a0f1ba164315625c406f5ae923cd2ae687c96840a8bf8a522a245c760668f76f5c6002a5ff5139cb32267a5e4228ac8470411e43bbc9473c9fa9e48c7c4213faf6b9dc2dc2368cb6693dbe9ceff3373e69c428dcc45b145b70ef1540b8ccb58328ed72be616e057a444c104c8fccf3090664ffc8148bfc3bf4bb4516e79628ef47380f4096fd45fc727fac0776698952c5a3131798adfd67b2e731f419c4a2a308e09504f996ecffa7ed8945416a0c2146e346c95c2585115d36453fe5d3f6dd7a2e87f158fe920d8d8fec480d2caa9db06ca71586f9e87b056d31f3e618923245cab19def554527f679aeb487fa351847fec80ae618a22b8b474c116c4708f4edb3a7d0036a105d6e00dd1f469930cb517ba904963ae447c1da58f74c7e4ab0a46a3f6e2009dc52c804aaeddc697d2b04454499ce8f8ed210f983c5f823ae5d567f6baa66b76968db8b0a680d3eadf92fd8d77faeb537f8165ab97405f634b8bbbe57edf1abca5f579909eddeb0e5bbb769e699111a586b605d1f55f9ea97cd379da4523581e2fc3c1f6dab3d3695eb9364bdff75875ceffbe9b37d68b89d3b4344d00664fd2646f3c094ac6d58c020c50e906865032b88e7dbe3317eb39d74a82a97477a7e7df585671a0a7db5e7df8180a5beaf9c3462da65886439b8bd990c45919fcc865e6e541fd14dfe66b848b71db7a19fae1dbfc5ec31d45980144bbc4a8851ddb0177024182f685529500480c4ad73218bc7ce88c69f1e14c3656650e78bd35d40aa240e69fc78f1afd46866bc5401159234942d8bbc2c2844b06556fd5ffe1844240ba49578ee5a1593596547fd375dec9ceb1e7f87b7a7f7d2432934ab4c9fae430225457b575396751e8335e24edc8ff8fc0ee760e23179c815b6c81415fa924a0d2e36792f60bcd28ad1d06686ecd744589472a0b77822acc28fee25b2346a6404329e6b2f17c4e0c4b158e8cafe5eaca9a8fab06c319c6d36a1df923dbd7eba5c9a0706f81923ebe9528683dd9241d62e5e184f16b5ae605f27e7823e4236dbecf6d507f176aaaa5e97fbbe1db9f41f313af6f7e2643d12cb535e6c121c44e4157cdcbd04d622e17ef0b5d4928ab02694f07213b87244d90e398a56f97b9c1ae73b254bcdafb6eeea295fa04f546ab449c33e90ca66a1163c961c00cf777c9d47fb94d07b85c4a3ce00987782c691c900994ac3d67ce269d10249a98107b5eb7622bd233e28fbe6fa5d80332965803c501456d6d6ab025cc2ec960c78b24bb240bf11fbf2acbbfaeaa4c32de8edeb356a90879213cf535560ade812be1c827d6624439f3809225421ba0f96059f1b9eca0294c38af31383caf91c45c7b778d11e1e2fa6122f07d92f6ff0e892020a0ad685aeba256ca06fcaf6026e7440920edb9e453f3cde616ca5d1bfeba18204d2d95daa7f9300c13eb9ae045f2035419189e52419c3f3a83580666812634d0a9414405bdeaf6fa7c845a36253f8ba40e45d1618257f4c6a4cf56a26f8edc38200717ff6dce911b45a48db5fe9d37dd79cc0ca045d19c15b02aea76b4638d99715223de0f51305d37e9930bfd95d59fb6d9cd80ac09b17e4efa5b7033f061f7e6f3cd09312bd562e665ac6a1cbaa7ae708376abadad7dfc87d645168d0f6a3ca2388a1f5d23814f1bb0c351c41c2806de85825fbbd161aed4c70c6ab88d722eca9fc943379762312f8d91fe9a33078f4479963443aba7f30db68f050fac9497afbc65770ebc48a398771bf0970a146ef73309583a13b40c5702ff18a1d0419882a2c9c13bd9a04cdfdd74a7248b6a84620afbfee6320ede3abdd74029c59db083c27b65c91ef80dd3b372bd120d0b2e79ec002ecf4faf17be5e30f96cf6cba8f8fe01e0386780e62dce2a8abee3c706865adeab5e49794f471ab4d46711eb6a0231b17de1bc2b0be8d33b4f24c5d22e947803e1722c87562e0672681b842f58dad27df4e8d77b84a0abaa13401fdb1869fc8ded3f2a952d30f5e35fbcdfb729e7b7521f0fa8fe62d5ab7930877ab6fca4091e2bf485fd0c37d0bf57fb16e9f26ecd0e178b3f104f68e9cce246741eb6962b02da3fff8998f8ecea9528fa18e9845cf5f12f4aa8341c3e7d6d43a3a3ea7ad508452bf986ac3a2f6d8d8724e5fea4f6382e1de5c2879c9952a3fbe6f8352c42ae3355571a901b30722dca663cc4447ee0338b480281e893bbc85fd7d155fc57c52b754a67557f309dd73c3f63d7c1a2e807f86eb85ae203eae112bc60e3ffc26bad50796b4f988b5e9c7478afb1629d68fcc6640f7c9d375c2708ddb2076a669a9936b5817a03c5826a1526ca6059df6f3f7eb88212ee0c301f718a38e4ca355671788bc11671456f1281b96e649c8566bed4330358573070d1ba67cfc5e3acb9575d2969c9c89522dec3aca4e0bb816b6470b8018ba4fbce2bf56843817b9575f050069b837020c9ce650ba3c8d116117ad9d04c7506da474a68c4ebcb5ee6f72e516d1933f570cec77d316fe384c26859b561721df2238936c0e36caf3085cddc03a9056d1714a7cde58803af4cf9acd579b477113310c4aa7303a28049b11e7fee7257e41d2e9d01a5ff74417376fa4110c012ffb56ada08ed2b12f818c219eb0ea7d8dade8e5bdcd38f882603aeac948cafa77d9c2b653a77fdf5d2437004d0d622bc6bac750819943f2e17dc7b75565495f9f4ef02c43f44e6ea18a9fcfa8548d31fdef322b7c023aa43065043f59a511ee716ecf5c64da9ab1faeab5f506a4d83a6bdd4b5ee817782ea562ec23ce47e58ecfb414ac120a2d1e40c6801140500ac310cb582ea0ac3fc3c5f1d09ae8b86cc36ebc6d98aa5c715531e695b27c820a6a655a7bd8b6058873822a6ef06e786d63b3037facaf3cdd4e5a1033b780e18045e4104618e8523a83936bf0e6974da74b507626749cc8f230e50a9641a3216f5bf37041c688f6d36004e05fe2ca4152d73810be8e25e3b5d87a5583dfd0065ab233268c1b65f03aeec260fcbd889a62a0c856981ce4c0153d588134cf68d634d16c40839e37e757a5f072efb9fe1de907ad271aae9e0ee22a54f6622d4b29e8ad1cf7a15f18ff4b61a982363530166deb49ad2135e0f0937fa20bc25433d5c917abad43619bed94afbab0c879e62eac04b55c171e27bfd437fe3d2bd814e8519fb41bf26e19c9a9efacadb98c80a5caef19677ee51317595f3eec29d624eea7185133367e152526c738f7a07bce8116f5d9ae0d5bafe62d963a9adc07336aa1d35522880c0baf950fb8b964ccc1fffb5d70b18a0466e05333e4a2e9e10b906a2e3a46f9035644c066d4add8e3436cc45930bcc6be1e1cba6a3947112c8c7656217225c6dd441b752f01aea685a155e4fe37772060629d77a00e6261e99945bf767f8576fdda01acc4ea012728900ae10dbf81bfd3ac3b0ffefe3eef31acb1e0a89c343846b84f4bf7546243a82ff8866da65489cb9e18315b84c770b298781fcfef3585b5298d280fd68658bf6ec67bbefe74a04ff3b5e15fa7bc5a48713597a44284358ae8a4da34b445f165249a3e976267bcd38d470ed9ccfec0b3fa06b029cdab524b87462c3ca6a19e9acc6b1028790c65876bc28772f961784b3d26909e38b632c9530498079ad19ae650d555224cca09154e8f6602dea4ac5c4e77bb585782bd59b4e17b8e680cd2f413bc988de4ea3e45e3427bd5cc3c37bc217f7b2455d14241a802ce76e5bd86f8335d3bcbed37e403ec0b84e513bec6cdd65a79b867ab3d010fd41446375b59efb368c00d57676182fff663faa83b84ddb6d49f8141c74272b6f7ece864341be80cb9964667e23477ced37b78884cf52c1b5c8d6b32b2e6949e7ad18bd0e9671dd598ab2b1920703aea0ca8cbee392ac8fca6a29e9d2a4d231492d0fe22c1c40bce258eb46412925c2eb93ece9b6d1ba712ac7c5e2998bdd0d2a1136fa13423b5cce1e3fa175a10d69df3cd15ab65d284fdd5832f48d308fa588358bb5440e49d0bce2cc80b311856f015bab2c8576f22d10edb669805b4b891cc7c85e945ae5be9bca1c8961720425edd228f70975ce5806cbd62152721b32c38eaeff97427a6cb85e92b85fc75d05e1722b6c94f32c314f3849462894fcdc7fa38addb7affb2a465e61a43f0a0c066912ef1159dab33eb361f8cacc6113aca6179fc1533d4b30c06dcdd2a5671467c0bb40bc9e1c603525fc4327cf99b193cc06b29606a1398fed39bf4206ab02d18930bddc7c7ba774af3e4111ef072e0887ddf3080df9cae5dedbf818873ae3a9b16f4625069fa0f183893766930ec00f6a8e219694e7b5419cb776948f99d9545cdf176d3c12fee77badafa1724d8ec6f20dd32e0b735e74710d4d4cd8674dbf8c74e4c45711ca5275f7c3f573a9db88e4216d788c03a5a416ec353da1550a90f08c902039b492d58aa5c013bf26cee34234e22dccf56c667ee2758e4ce959a5e06a58ca3b2a916eac567b613289b3a6773aeed46e43554e3ee5555f6c48136b31888f552e88565293db979c3e6ce095569767b20516842f8a081a76ac8fa068abdfd4ece3012a0dfa68faef72a33f1a94811d361dbe4d117ced2846d676e7370a2cdb1392971c628a0078ae0ee4c1d1f0b1d7573c1c760ce960d5c20f4cf1901a55cc9a6778dea7ae584e1446ad680d54e51725561d3395fbb969cba0fd2494dc081d4a740b0f51bfebccd2304f3fa85a760fdf7cf6b3aa6409101eaafe9bb76ff20138951fda2df4560b6637e974234f31cacefe81df93dfcb5168bec57e21bc6bdcd9472e9a1a53c99023c892bdb7d0748cc7f8ae40e4498ef96e439469385c4dbf6653a746abc3720a41c18bca305f2ae883f97a881a5815ae7225bb7e5c966521cb4e2a4b48da082d028cf7f87380b9c9038559b80b0140a5539378ae795374ce6fbb7a454f9362aa960c3b8e3c9e2239fb6f87c713babc41e9976be5bc8a3a37c3677f1f037eb3d06eee1b79f65fa35f93ff43770f525115138bb3f2510f5e484dfa9376c08b62fb091318bce61c8d699ca964055f337b55fb1af492805db26620eac91c5a8e2ef2382328b8ded4cf8946e3e5a165712a5ae9522d34f23311212c5ea3d860c0b8a430f9d5459d91fa60ce43d52845fe295ca376c658d2b7e2508c338ef753a7b2d4d1c2bb9d6dbc4949ff7678cf06a598ba4aa841e140f88892cb5085591a05843a9eaf2b8fb457c0161b7313921e6ea0fb6a09709002bb2c14e60919b9bbdabeffb20ee46ab29db45cd527f1ef98a2d6bc809d314f563f721220aea78f2cbf609ea43712b1391af0100acf90d063e4abca3c306d7f15d593c6476f888e7c4486f9121d5422bf5dbb3e5410b32e51acfd974ee443c6ddb70aa7b0f169524b1d4ea7b5c3ccc45d1b8ebea791d54e4fb9f9cc39889578f363e4d6e95ac94308e66fb8c898b6fe4d4ab001ac54e3b29dd7a4fc7fdd0cda99fa7814125e30934fe3c2432ed97ae4226076f27622ebae15ee747852a347dca1a07b0a80e66eb70cefe66f5ab9875981b2ba788127f25c7f6b12bb6c8da9a191c8a77e9e9385363a88cb52c309b94951be262879c4b84517547e6fb11a30c8afe2c417c0585d4d356f881220ca457c5aec93ec2b9962291286a16e823321820fdb50d5a5785b6844efda6f91786c7834843787ef0b785c5d69c99edf9287f05e66025ad916d986eb5d6674ccc83177e1eaaa66d166febe85d364b3e7bc3d1050ffa3edebc7e10c2425a647a52801c4782a8fece773b80dc8f3fc8be17f0b170f20fb9d918d525fe408dfe6a7efdf190365c6b21c6514e3db7044e9632c45840bcbe7bae69d645d87002d28de123e193bca464855b7abb52d145d35b43783213f93640a8413e5c626be699d758ee7aa430ac584930c7dfc32186eb1d897aa43c15ca1fc92abfd3b513d0f84dd7fd42bf4ce1dd458e356e8b800e174d4b1791346c068d61540ef5c5848e46caa97f2df3ac876ceca9b2c239a7847e1d87976de3905414e53f4a215fe4c5ac5d947cc0adde0f46b63661f432af3be5717ba7caba1cf9d4b10b6ecf7502e82a92f8918ee991ba526ceccafeeee73ee49d86def15d9de009d7f4b91257f1a6a36c9a1218f330b6ff946ad78c367e105ea154df60ec5d5ccdefd2fb365e641940d10a16747757ec075049e5f94079935fce0f9d0eeeff7834263c0c5d98a6d315417ad1e0315a1709aa33c4d1dbeb816496afccad994421b3f43bb309220d3953f3eed5158626969482ceac4af938e73b702ac86a2fa4150768930cf7ae55112f2df8d2e730e0560776cf1e87c9e40f4f9f312c5969ba1dcfd4acd28884958ffd4602590501c35143c959c6c39fd06ed5f2fcf3bebe6b27ded4c0338c3a7370d9cb828271949f4565744d80d8cd3cf3fa3b530420a040ad2e25a8ba88adc207bef6833ad90e5f14412d749620554ac6bb678cc1928866b4f4458e0b5c5036b2fa640f2776b947f692537c02f23455c20d75ab8ce763d1923883646774e25c0802d4a77415e5ce8c15e796031f358b93aecd9f3dac209d731b6fb668e9dc484a1dea544629acf69588f47de125dd2fe073848c173c242887be5350824c626933744637d36f20310fb51835055c814df89ff33249739a89b2a8c1e68bd5e66835c52cc9d3083f913c31da5deec9dd5105ca883c5c53253431cc8b474c2d1e9a05c1f7cece4b4bc9840005d717e1def02ae18a39761dffd3f073ff43f69997d3534df09a23a87063c5549ccfebbea9642ea5f85fc3869b07f0ccccbeb4316efe5d1a6023251b0715a68d54268060728a20e781c2f71cec6ab49ea33957be85f93f243f604ef218aa8f6cfd2c4462e6e2d6c7705cd86bbe7985b50ad968455ac669626db3c3bd27beafb2808ca0d2ee0bad990e97df990d337a8c35a770236ad11d722c6b2fe771438fa22f3c87f881b882f9fb89fe809754f54dcf52581d12b2b59a0c735aa51b57e9504206bd427491a2dc03509f82c276c8a682f2588481aa28ec1a49b99d0d7e990e50beb11ec0dcd0d8522b96c4d841d8c53858ad453264bd6a89dc615677a1b5ac23750ca824af63f160f7390e764ae2d09daf50f83b6919ad259125c48087a1c2e2756b5b5593379e66e766a3582982f23d6b8876594f1875c163f011447b98b2707c100072a1cd7bc0d3e51ecb6b00a820c1b869cfb458a9a50f3ae64622b7a30ea6cd8c19032d413031d7f1db141b99b74d4f102919b9efdc0a3c0b82409840c5acd808164be858afa233c22cd63248832b6687acbc2aef894206b75a08c8fdd6e2fadcb715e27873f053f59d6f08d5bda8f22f3519bf510235e27cd4678e7f8a474119e131f59765758e9623ffa41ca70aa5510ba9b3fb2ad9f4bf6690</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="Hey, password is required here.">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>扪心自问</title>
      <link href="/2025/08/12/2025-08-12-%E6%89%AA%E5%BF%83%E8%87%AA%E9%97%AE/"/>
      <url>/2025/08/12/2025-08-12-%E6%89%AA%E5%BF%83%E8%87%AA%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，你的权限好像不够哦" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="08b790fb9f5cb3cc96941e36daf66aef925fedb1c985cc51bee56aee199edfa2">25f19230aea40b808fa4be3db405080d6505a010b12a855b56a4dee508d72715ac941b66964e275e44c2ce481859478d3fdafc014d61f2731fee6be644a607414c2bc8b4b55d11bd095c4c47d9b1040a33eb68db33bd205740a37da4b171631ca02aacb373c80b78aaf9d73f2f0ebd668fd8fffc796eac105baa3a069b0e36146419126e4c44188d0c338d6ce6ec5958c709f5520b90c1e9104ac8eab7f415ffe7915a6c6bac27f75ccaeb6b36dd49b5ba8f634b616a9c4565ac5a19e98c6cefad625a7152d8e944fcf85ea8d2f5cb93a2942c1f028ddde8b84fb8ae856500d007bb9ad5c2e668d51ea80fe8f9f577cff39aff16495b812a22c17c49651151606a575fc0c67fd58174c8d26c755ca4f60e04595c5ba85053b0f1b9ab59034b5bd34cd1d63075de49d16746328a1be2bbb707b76182e10de2aa6ce7040c79a2693c5060121084eaadc998c235dcb9f4d8ff499fbb3648b2d01f69159e71a53769e7f5a21b0c462b511aef0b1aabd69d4833f61087ead0449b8244a462c541aa58ffb7a234a075962de707b969157b6b822bbcff8c15f043e1d8a8c22968c5deedffab94ed63ec2c8353acb99c93bbbcd384e16fb2839412c9a0605c7d6356185276900b9dd11ff1e1217ae57c962cf5e8ce770a92a21eef9e63957a20b08aa299b32cb1760782d8292aa520ae00a8dabf5932796a78ad5efc5bdde226ede3771a42f1c2d9c800fb639ec9327c69ce913abff88fd6a5d17ba644f2cb6824f29996a52379e4b411273a33f065b58dee38b1ea7761003d5da6a4e0a2108f24507e3afbb3b5f63a4cf50b79bbd033e2bc003c11c4236a3c8d5595f3bc955e88b7e8a43fceadd3b25db6752a7bd42d55e39cb293c6138a6d732fb44a59a19b141029b9a4b111ca375c5ed55185c1af75a1cae6c6efa6229743a44eb118c74b9fee1313044ab44903ed8907f16b94e0fa1a64bddbd61ef42d4e69de05bf772cef3b3d3bb448940767366cfa221df96d27086c61f1f90b36cb80fce8315fec9937fabd83bad1ff87d0ee3f4797493bfc1f960fec600eb43aebd32e91bc183ecf417685503ef031bdcef4cffcab93ae2ebe616d0e28ddfa9a4a49418be26dd7e7b4748102bafbe9482f09ad18b7e1c0b9402e9c0ed5e89884f509f7b914cc02eb07da1970953f3d3fed5c848c2402e0ec3ddfa27e98c9a4b34c0c7e771acb1d6a0b18c6a61ca5e73e5c5934b0afd5ea2cf951cbaf37feac79f762ee98d56763f54dc90656245e977703f3194125e6838a932399bc496380852fe3ebf3b11ea0af7a44ddb8f0c1e6236c26846dd9d79d4d30a78741839c6731a407f50505be75151172bc384ea3c60ec87fa90864252dd03a4b81591d12825a8b25f67aabe8c23418d6b292e2017958d0d088fb9a72e65f462e659be844264de0a219e781a94ea4dcdc7cfe68855b894f8313a598a5aa6d4c319725c9078945d4b44c463ccc1f60fe6989feaacbff520683764be17b52363d45b94e9b17d8b75c65aa8855361f7195696bd6f45788c602d74d8cb6f07fc57681ddf6bf026f90cd3e6deec52eec1c104cc60eb373037bfec318b15658abf00c6cb54863bbd0bdf7d864b1604fa92d7c41083467f43130c5f3f1c4682dc2e222355e187cbd998c3b9976d2cb863acde2b6d45195d8e4e0904857aa01b1d017f92e112873dfd471e15c25ca5a6731a8e8cbffa8c61a098e060d98d2ee9660597bda75000dcbbae7d53601a18e612e5e88818924b3e218e322b70691195043bfb12de0592b5f64a57b3a3140329730c72618cf46c7f5557a8032d2732ae8ada4921414bcd5e416bed48dd841426a36686d96919b4604be9aeec43fd8a43155623090dbdb7bd80f4f22f7672a3131052059aa7d3742578364b462d8e98eda3131932c1886c3e9398f815be5e593fa807f20a2548b37dd7d617a7f7393623ed66134d6f8581323792d56466fe1a9caa3e468849d534dc71cf95a387b48d53c4545d3bfc2c3991bf62e8665b922461b41df85b8afeb4c12f35d3fee66682c3a204d7fb62290ce463a96f2fd5a7df6f0f498b550dc9fa234cd652baadf8dc158e48c64916d56a86d0e1cd5e1ffe65f015e612e846c3524cc5346da3aece24792f27fba10ef9333c74ede68ac42af1d8a4b624da741e03790a190068c7902fa3348e0c927bc5972bcb45f78914c8016a86f43d590c582ea6f71fd8d359fc74fa13b9ea2c59a320aa58db730613926d7f658482a4bc4171a044bbe2ca65bc146e096639eb70ece05f26bbbd1a1ae97ecd92ea02ae0b14cc02d177a0c2cd01d0147c1b5194e07446d02588e2b6c9e0050ea3f6fd0cb468c4cced4b30d4009562e3a6c9ef5c65fc731311bccb930f21946d7e72291b7f6886b57d4d85a8961b158bbe7474af64b2dc99d8f459df32b87cb8f38ac9ac55cde46258c533672288aa78d7add97fee8d893188a25d500a397be2fe0896725b85506220f57c49c08d89e43bfa4ef80eaf7c4ef7828f3e7169ddce33ccbbc4cab80d11d586849e4ffe821cfeaa3388441f84bec3eedc88a8ef4e9f48f5284d29ff68990caab5e32e0a441fae9b17caf602e367866c90e72c9366956a0ed3c87e75caea0229856e8dad2c65597ccac639d4b6f2327c3bf43cefba21019af316779ab6cc63d8dfcde664196881831dc23891d199838ccab396ecfc78c418926ef6572bb1fc66261910c12120e336de602642fb76c082fd06d000412d48cb8e917e3882a6f2a10f78b6fb85ebd87e48083e3068ce0f92dfe8b5e52426946b5f255f78b2ef9ddd215c3c94064a780e2841e6ff62d8dba4c9624e78eebb921bbef8517bbc11be4329606cd0b7d4ad66453afb905651d9eb414e283c2e7a8a23621c30edd0519d7640e0ba16ae502cb8351a8a645f1527de027edf5adac194d09c59ec6a93cafe1bb2c95af64da57fed0b3c61ba83a404a202921d9ecc8720af7f961861ce0f8c8c0d5a812b13386570a07801d8d741a8b48e16ccbd393142d7b2e9f38124cbe9637eba0a2369daa7ddc0bb6ec71e182d447aeecef7fc590daec628955e6d27fb7c3734d62979fc757eb2c97f43560434501483b8a06ab53c4bd5f3e1bc2f4e10fde20270b94c2ea84ee394740c5f15264ef19452c47161e6207be3fe156311911274e1edbe79797d28af6a2b3fe8bdd96369fe34c89928d11b2d630f2939eb2873c5dec50f6bd57b0fb30bd236124482ce394a9e4f8567ac6382987aa20b8018a3ccbf166fe39b9d6930885ac6165f9686ac63980fab86dcddedfcde82d5e9cea04c084e57221be5169142fac97a17342f0241b49a2539c2361a9378ba8ef586250d8ee1f7a0c5ec8975ab10b5968aae109b0a60f49fd863bf288dcf40e07ad0c40d164816cddcb480c1e27e4349abc81b4aee06e23ced7dbb09cffb228504b0d096359ff05753abfe0254d72fb4ea8f428bee1a81e7d12e42070a38a61eb3c68643474320cef0b1e0476373ea288bd00a08e7a0f62fdf11989a6d484f54f388de16d32603d7ef6f0c467047c59a824d60b81be2096f34e9ddd0f89ea4cbd79fc20b2f7c38976d50060929d022417b339f60da5c05e04c5d0a47b4e2fcde698c7de4ac881fb537cd84ccf478d8743b08670960b8dd23d5deee4b960d264290c73192c1ba404cb8cd292679444a15ecc2cf9c814f9d7dbf1ac156889bfcfb85baf4dd8896b94f079361b4e24014b4038b478308636fd2282a0cf7ecde5f22993e0bc1c4770a722cdc8f883160094e9790c398c31b6b2d1ad504d099c73f5b4e27d2d119d8a5d83a6a747a27efceda53b3591e4cbfa20ea88e60e72b46b840d4516ed539e05d83a981da6ac8109058386068f361fa4401169f12a11e0f4a87b218ab0d250b9dba050d55cdb678eac73824959f159649e008c3a6cf0915a64ab5fb219f73ba32d8368278ebc8e4bdb3aaac61fe3fb939182aea47d653255857aa32967f5b451f5879e1f2406ed580b017d23cb092b9965ebee5e5c9d2905e08738a1f31345c6f5f5fb956f98d51efd57f45567271b33b034ff32eedd97cc28bc40b2a5a9405f14cbffea82835a6a9386daa122d9157375e122b38a754a54edf31251a6689118b509010153cb162c2096687d6bb81c888ac71835cf066f530a509af865b7773cac9f68dde9a13a65e4643362216b377cbd0c781d10c1cd3e121e186eeaf21b0528345df2b73608b01ac812f6d7d1f82ac9b300ffa78b906e0299627bd64c040b378e4aaeb1f40d132b230324ab3ff5d00490932388ea89f46e81e9c56658205fb5aad0b42089d001bd088ae1d0751e2de8b5aba7ff66ec6a275431b7fd64b5bdd9f74b7e6de903c709cae46ade3ec8ebcb47b4b040899611a24f12c0838d3d2f352bd23b0daa93d4e968cc513a4a49039c99c7ec62ccc1c6db5e809c931ea73c01c02ce88ef420af3591d8eb55c4d1bcbf404e1fa2570fe0a01032bb0ef95c5af2fb6ad12aa28676a57f0f1fa7d857837c296db61474d74cb3aa6fa36aa6ed47a26fc490d633e50ac2c59095a6a6590325e62efd3dd2ea88e7dac7bf6237455d42cd86cdf23e177994d5b3d1779574579b9216fca7db4d75bf4440ebb1f47ce91f5eb9a1f505090b8d59e45d34168357cf365fe93bf8bee6f46fff9cad2e40faee715aff196d71e4ac5d35ab15d63d61bcf5ce41c1fdb97e96cf28158631c3b53fc3667159c635f534e0fe367f3f6c55becada2d395395adcd82f82ea2d0abcded900b4b4df139d0e2434d96b3d9b770f071f3b7a8d0c438d6a14c94a556199d029b96eb4690879383972247687fed9b36dacd8f1d6415d782c27b7e7af83913cd9b48fb043e8fb25a256bee9b8585c8abbd48f8f507bcbf2058944a592c0645a2972a374ef779444ff00d638e1a76a2a05e4a96f1ea45a94d7e8f7f7e453ae65578d7a485cac4a1aa94fee10a253e00c5b2bd3fb32775a94fa2de71e0e4bdaea6983154910069ca961923718fc552178ea213a26ac976d8dd690418660bb11790bab79c11dd8e57b6a1cd2325b21e2661e2283d0adb2e43f2f31624d9075a3bcc2c227df38503ac9200da4a083c10dd5c0b61db6a7e89f4ba02d15e8dcf95c6f554ff8d2b368d6fe5f9a56d5c67aa258ab3653131ef18e33d95144618c2117e822b7b0d4bdfd28420d71b926d8ce814561ba02cb3f0ca535cad7642002971f564c54b69c76d5ba94c5435f9b167289c30fac12e5085b7486545f7ff5c7fcefa384293ddb3f9a6b78ccb8686b459f562c3499bc3427b96abb3d7f5fd615f6244522b67e95c804667c7f828b3ae9a542d95bb3dfc7d519dd982f9d89bcbf41412b0026fabb6a7cce157492b3ed3cdd43a0f5993d6f643980541d1c0e09826c609d9d62c97b28d79b51d92107d30783700f2a6a07ec174e9dddf7a1ff584053a729b5ff958e93d4483f3a2b678a004cfae626b6ab0874eef1eed82dc2bfc2e5e64b2837271bd3567f2b8fb8a7e041361ef5312a72879b8a0be0cfa9642dca0d4dab03884d3d50d7a6a96fc5d61ea08ff3e8a44b6b90d4ddd29acc607e7f27386578071745e15ff906aa29b0f29ce27498638fa7b26d4f01fd98f369b24da5554eb1b19f472ad8caa124996bb5216960f87e6fd86597e1ce9926502537c9628f9e5718482932361eda84f48adb221d6807b08115b4f2b9c2f6380677144dda395f728b1519f0992fa33ddc895952717014c94576bc7c507e6207c5dbcac64a4fdf4712c0fbd1640918908e6a0aa2f850d4ae344baa33cc4f6f243ad794d93608dd75dec4c3feb35f5f12c5d08f040e75c87949aff0c177b6e72a651dfd9e4b534cebd48a5ede1b95554547434901dac9858d95f4749ad82bc3d5d041945c5f0b72e970194404bd4b953fe77a6f1c299bf5ec0c65ff36be8bfcccde48272bf63358d23c5f6484faf64c328ef5b7232cf8534de18ef9eaea4d5aeabee84f04e8de30d4c76febf94360071472d6c1f73bf067515a1ad00831eec682d7ae1ecc214880bc48624d4700ce316c52864af98a04b029b08769df8507f8cc58e47103c2f7b363c140b17b851e45096c073eaa409f98c02ee16cd71c57e4c61c05f10c1299008090a708c423585651bab48ed8708b3feb6f5df4d2fbae25a46fa9079ccc4c10dc6d051c2c64f3eb02bc104d6054c59d6abc35eced69522dd6e0b0e838a00fd49bf058098449902f2d1a37829887286bd31a307a2028745a84687023f1475a1a1aeaf46462a4287129fb08e12f65d9f335ac24b9db92d0dcb9eccb5500200743d46853b53b9cfaf5b2dc8dfe9804541b8aeaeb17097f47cf7dd8a226278c4d3c363d1d28f5ddbb091b1c274b6fd3065defe266d5f9b63d5799be54c862fdc4f44ee847971eb6f8b80b49b17e88ed5a3a95d68d781ebdeaa4e9769a258b4921ee84a59b061806d7aa35a4efe0f7dfb5e9915700ec0d7230bdc1d5f0ac9e4281ed4557f6d501030a257f7645da7e0c3fe1d134fa599dcfc56cafdaae2f8b2b802905ab609218edf18b41ffa0b90e06d18abf06d585effc9322747dd97714266f28e72507ce856d142a48e6f3471dd0c6fb7bf0f87203af501b9ad7696891d691500516f78cd0200c43b9adde1d93de0146ee7f8d078aa43db60e2307c0f783cd458954da44f02cb375bbdab0fbe1e07ded6ff4229b8ac40a5e25e9f4cf610b99a6c23f80059564f4fd328d39e125a9579445bb5bfbf53bb2f72d63254203e36e6727306c2dc9ba10e72dcdcfaef78c711af7e75ec609959d965208c38e14b615aacbbfdb396870244d1cc8481cfe58b12f5a02087a87bc066c6ccd4d443804eb30e7e5c0098fd9ce819812bd8c4c73b470db5331719c08cb71d67d290331dfbb3dac371d051bf262a63ca2c0dd83861edc10af4907839f370c10907b7598c05c71ff905df1edf41dbd8b1fc33314b3149c31bb959d4e9dfd8bd4e7f991435a733bd500ab2015bb351bcd4d68b702d6d2913fefeef12d8a956fe2d492c1e092fada650374ef85ba2ac204ff4c005eb57cbf8972b66b982d965d917c28b04051a3620adb79baf0bb49c01498bd3a976126151cdeec14f387c5d4e7490c6ce49484644602903736dda290b6de3d122fb538ef1421755978490990b1b2993479f6e5d822a607235187d697edc37fd4e089a5cfaa2c0d0dd9953ef61c59dea67a73a02ca45c1654aaa9cee7c86f8046db23f8bcbd107a93ed4a44e8295ddb771c619bfd985d162eecb40dcd2a59c3bf06519df22986cc2f2e5061b81e716305750bbb78173e7241abfc50faf37b1fdef9b03ba70665545c29d3d2bcf7caadf38bc3466851dd10000c7900710a3354cd37ac4a3d958bea3c25f912b304adf1a14f86daf323d76eaf16dd6078325d530f1fc230b526067ce601e7b20b0172905714e6b5dd68d4b734c4c1bb3db1bab6b509ac9a962478d547e9c8f42f08247a0824f97c8f2616f9ad3138d26699491b47b1c2fd5935ae23390c27052d797f3c5e1ff8babcccb69ff8f2bb47a6a6382c932cc481e921c9f1b8bda32dfca135ce7d52840059dd163bee63e5978299824732017898678d167c51ce81e1277729c21289e2908cafdea914ce87cfb3c4547a19bd25d07cd8083aff1bef9f815dc08de100c6bb95abc77b643495eccd4dd0e0fd5e46c3b7cf4ab841e1450f7b50b0680d2a0c0f4d59c76974869dede8b0567417d0fc9470743a2a32783becbee0e1c547a810e35bde7736c5e9536bed5d5f7952779dfb6a82751505280f5f28fc1f0fabe79d5581da3b4b7329e0e78c290a0a3a6eadc73fa340bee68714ad95d37b451a0ef9e02f00ca8c91625d2cff5b5a7653ac9e6ac7c2d618af981073136ba8423ddd6f71d9c69fdc79a071985b2e1aa6a0b6eab5f58be4f040ac017b3575d3dbaaa9d6d53639c947fce42b1801234523c7ee4c2b1ba0c942fddb233883a01f47c52ab273ccf207bc102ff8a42ad03f10949c55bbc1d1a04ca187f37756761b5b8de27c0db4659c8942ba99a9b37c191737e07c305c5f4f13b3ffa50f52c88484080a8c5b31050f7e7bf21795352efa49bf770bee93afb3ebff836107426ebedf3d2c9bb8a7f5e6c2699020ae89c5ca213485a7b7e87efcb46eda3c5057e221670e8f61f4165c8d5405d36806f0eb4a70bf669a87cf3fe09b096db4eb11bda2709d1b76251155d1c5565c4eeedd5e44eae0a994f21019cbfdb8bf4a367a4b6181d9d47e62d376d74433734a77150b9aa9bba28f87214cb8e2eee05616b0308d62e25172f5ff576eb03bdb0ababdcdf355cd6dc5a78f8af392140cc00e384af07ea8db98925fc45eb0f2729e7d4fffaa5e66c0b360787ecdd0a955a35b830b321efe807e4de004dc1daf3af84156f421031c9fc23765af2c3566d5d5028a7712d6f4d51ae54b49656f6c9915b7d20ce40529cbf36321ab4a7b6348407f67433a93a5b52258b979989e400219089444a8d871b14f5ad07a8579b7e3464dcb1c8aa6b612d4552d9c5812576337860105ade946d9d1d9740d6390fa127b148be8642e85f12d08dda522f1de7afc86b5ab5646f18a00a072275dd5444fec7ebf66f8be95b2e52b8e123d077e3e652bd65f60a8d9f5628ddfff31dd3ef61d7278fe7d55e6382447789843f0648df3cc46e0f552d32b3519d72dac1e3728d6b709c4251c6aa20bc9eb732fdc5ae0f7112592699e52ffbab02132d29d1de01549cf56489e403a27ffb23130a2507ba787072c73c6bbc034a06562a673a5ce3040db65315e3e61f0bad3fce16fdd187c193555a5fad83aa0c1a4ee9bf2d539d370067519ba368a9a09d69c56661cc8399193f6306a299baa7329d11991fc143520c2f280ed154c11b03c94643c09bec25513eb52002c863c7b754a99eeceea9ca74a99e17ef43953f653f51c51577ed1221161f9f0c5b36bedc7015422b6aec97ce71aecf647a084815f661d61ace461ac2ab314ca7eda20214ea620b1c6d4966e59047bd950610b7eab3d23b4539658019c9eccc7132209d4109e11a25459af217b4835b857897aa6293b6057edd65434f859606a9323f19b7af0229afb5d7afafa5a67fad34a3e49120fad3f0feed2f31afd48bd5004557eff5935557dbd2859f72056fdbde974bde87e9449a3be6b5304b12d31f0d46579851ea46010a9e857029580da31fbdccfd200e4818f5b2a307efb4fc9ab414f9a184c8ac4be8e3456b90add6b7d774c27909e119cca727c0454c508345f856ae2980cd5494cde7e9cecac9a9b6931f9331eb0d395304c4e6be2d98cb5789b14d7a5c127d33546c69f1d4d8af43685c1494bff24d128586d84a89cb65c5c07129f7a801ea901730e5c9fd0ddfdc95760b99d2c2029394cb6d376ecc1a38f08e898a7972bd6c8c0653b7a7089de52af6c953f7eb1b7271d09940a92b937abb9f9a4ba1eaf5e6a60723370166f55cf781a58b3c2b6909e3f1837e97b3cc5e0201344a45d1c38ae8a854cd0c797fe0726e372722c59bda1398755d153736500d0b646a8f65d23017152fae8d646b19c4c2dab7dd64fb3361a2d0a951d4b981af5dd7b0c63fb613701fa0f0bcf652d5dd1978498df776096fab17c1b98daeef9ebe46ccb57ffb4882568168302d534234f68e0fed09b8c74f20318f237829e44d93105ab5308d88f339bfad22969b29e9ca8e6ba9ebfe80812e8ae0412fcc30b5c77a2f917e148192b757ffcbb294dbb323ec77933314004a430a157151ef904a59e6fca9a9aa516ed334bd8c0285608287f0d1352d5eafa4f05fd2f055b3b78c0a0b4933bf1678fcf6b647b7f822cbe818755d4629586d675abd193fc0783094ed16950c9f46913c4c293af4eb9e1eeaf91cc797fefeeddce364a719e83686c2946e2f61f4f581aa13b0bbde98ec41f935df4d553ec4b01e4c7081be36b1726c5302a35b68497de538a28a8a5612f5bf4f9433a9cc5807e7c029c8a9b815641fe5aaa9fe15847243f0d3eccbba4b2ef929c1830fc3764a5f3194599b8f359e31e55c74135021ca21dea81f80cb5ac12b78dee040881a38810d98eee7a6551fb3b04b7a2487a5019228d461e81d251a31cfe71016a82aef7a9cf090fbeb5931c72374a084ea9f29cd25f01724f6aba5c22dbcac4a37c259906563d1a320fe455f572117c25db5df577822b75d62d5d31073748323be5e0a003e917ef7ab7c6f076f2dfb61441a63b206841c918ac954ec2494974a2920586246abe999baa08af2d99e4d47aa0d9a8654efebe5311cc4620164228a3ab5427d83e663f5d8aea9d25a6bafedf057d93986fd8e9e2d50f004ead3d453b788448f6a8736168270a55c167ecd5d9939497c9449c5e334951127568c2fb4cffb8ab42581796ebb6459119f3e321dd8ca3e943ea8fa2ff85d343dc72a40011508bfcc2ae0bd6f294f604713b83934df99f10618632616f00a1baf1ac0260fb293a892be51327ea3662d992c43e9a6a674279213491bea7dbfe93079e964964658ee1ecf96f5d94601b5cfe98dac6c4ab80e2895d62d448c1ca783a8853f8a275519a9e6210aefa6ee7c34776dc5ecfce4fc5b354d98a5235c743bba39a433d010539f1aaad262ce41ebe9caaca036bd0178f86463f609ec12b1dd9fe233e59276fbe96c153b004fd4da151d41dbdc1cf38edc7f5135bf01f79b1c05e4e28dae43f2cf136074363b53acf7cac64e378a5d3d2c00aa758e8a76206d5a7707266ca2311c65e12522b4ecfd410931d343e863e7d6c4340311e300c7b059cd9ff16e3bed9751e7d03e2f16a30edbd5bdb142f651fa1eb274227cfc695f5b67166b665cbe0a2582a7c6ecb27916bd5a6f37d2e2694439ec9550933c84d312ba64fc1f68ba92c7558f3f4f474ba324ea67f4dc48f433f7ec0a03561f289f5f1610d7a980f154558cf98be5d243b3cb6a959dc4a569868549463958ce932f1fd198be3d4010aac837f64728bf21469bd8fccf80183fdb7c28dd8b1caca21aec691c042dc1972fee4cc210eeb45921e179f42f9b374f3e41942af5678f3923ad132331633b4444e509b39243e1082846ead45d2a9ae1876452a66f2135464907e527d3b92cb8ebc8c92f6233efc34e4b3c625865b985db73a79c91a1d9b26fca9adb64fe6df93fc3588ad263bf87372a17c0e6231679ea174b3f995b9768492ccdee00500f0c3dee53eed7897331038a30886410242f1e0bf6025ad1383d8b2232c1f4b88a0a2bc864f08e077b0f3a4dbc778d340db894ef3753a87bd8f6bfb5916261a7e357d52e2119690ab037c9dc44233b58f87837ec68aa4a5b0fbdd5c9d3270da6e0302a3620e921ed9f70cf703004fc02b75204490771aa40ebe872d484e1046688f5da39feea82dfd9bb43b39e349ad8bc873e5b4f19aa56b93c97d5d59a59b51ddfe5d2716b4f31244b6ee8178906c40d12cd8bd6ea38263ca006c7d262bbab03f8a09b1607fb585c31b3c8d1249dd1ded0c37d0381bf4b8282083a15fc70b5f2e2e42a1138eaebc4615e4644d96e5a8f47f2dcf55817f442dbeaefba4d1b14e8885f6ed5bc2702904d433a915dd4bc196fc043410675da6371b8844ae7ffe2d65dd6d1c35ea69ff2b029f07da168c18c8fc696f84e32114a5f82ea94763a1426945738c4e4f834d25d6638faa27fdaa5941d86e82cb04307f683066a381f27f65b144e0199f1417e174b6b548b423952387fcfdb7f496f5c318975a999341e0b195e8168b0b87c112c3b42050c612b21a10421002b2393407ff15c4629fc930026133fd94da5ba1f4ae5a3d14b8e42835e2866acdeb9ec6e6d9eb8c0546243992d0afa07148c4278e3275073e660d1182bb301432f72dcbb4fb92c838f0c77f91dbaff6daef10396653a3450d34aa3a7608607943597669d0cdeabab07c0fac7345f0029b7ee164596fe76c2d9ae3c151bfaaf2b0badf284106201ff4b68d6292eea5e988cbae6812a6b505ae95146f107c2dc66e3037ef7ad48128e2996fa3d10bebff1e292b9b31f918899e2e0fbc2a7a796afedbb5f8e6a613455996d9e9429a0c1e53ba55bc8b6fae66138d185d5f47eb338c1fa5ff0f840a700c2bee6432e8f887c7608d4e42d3a1e08a8aea4a754db4a5c64b57e7a823e264698e9df4af8395a70d2eaa1de218dbb2efe156ad9972f408807e8beacd624f8d5303e0c6ae513407e5a9afd00d2f03c76eaae7d253d887de80e53ca86b5dd8931ccbfa14bc62633711128e6ddd31030701bed0c55f6396aa512cbab081efb4543ebdfc3cbce0d60e145f9378d496beb2c53a7d6a6897fd598346fa55d24de44decced67ecd2dced390f7300d6f0069be514615a8ffb96fcb0729859c16cf850d25f8a98baeac7df7ce717571a0e1257974afab530dac303ae7a0362eadbccab81c99b11875247607e65be504d367671f32f4124824c50a4ac5ff95e0d671b257cb4ba4d2962a284d315492291a06e8ca3dc8574a130dac878a0e855a07df2b7103212705321535461afb2c02f470430d2a92eefb7cccda3c2fbaebae159469c887d158b5f30362228ce903edbcb09d9f5480e1e0290bfa01929310f25be23176302d565cdc497603a90c39e4b10bc4bbc9ce8f3a134e479965e7cfb08089fd3efe61ebb97738b0f5cd72692477c5a2b48689e09f38203ac580890ad0b46aec1a31f64e943aabbd8d0ad9d47109f5e9a3df3b9555de9e321d28835ed614fc48b404284e5e8786835be459e528786a4ddab6c0e317d21d72653874596f7eb4f0feaeb72d5390f4fbf4726a8ceb029a6816bab97c0111e888ea08f451dee26d503c0a141b7e0ed574a81300718f0748196005674e39c59a348f266f39beeceb54154ca8d8c242784e84d70d91de5a2b360a09a8912d9cc11ed173eada7e11efe45dc0790680d781afedc5cb06fcc5da1502cbec562c5d3f0a6098aa2186ff0695b61e5ee4ae8f9f3cb16c7e86a99379a47f253203021def99fbf1ae68b0b5ddd04a87245d1b0da3faf6c7002a761883ec28fb6c76249869f2c1a2a17576d58a819024a84ab7cf4af999cc94e3e80163bd343d89a797fd44111faac639e8fe393e53f56dca4919d0799001eea3d1948d50ba0dc4185b9d38603114af2a3f9ee6c5be41adbe818b3ffce8942d2096d56825029fce1bf64c8434505c9bc635054177200dfa2f9ea1e3c53056ca8e8f9f4148830a22cd02a8ca393b7e38c1821d99540fec62f0bfb52042654f0fde214d7cca3219a54d3ed35c8b02f109cccbe69c05ef49bc00f5f6359fb5161844c2f61ab9045394ae547b57409723f1112836db6d3bea54ea9fbed5cfc7571d9f7e997f986e2c1603c7e6f028a1ca092ebbdaf192748e87a435a3a62c6765d8724be638410fe7e3b9b6881ce0b8cde2a8029c707217b3174102f7d899202056f931f0fa84a53b534c2c26e770d3a9ef67f45691dd276703d5e3dd090a822fa40408656d6617989ea9e23831e9a6551abbbf4e799b59c5bc4f3ceb296d4aca91b1e9a818f109e69dc1b46879a93b8c9fdfc696b491a600c31c4b21daaac1221818d7142d7657de2174a4d1ff03cd83f81ac1b8035516a6cb4f7689f1540aae6a4fe3889569d684d3e971f51d8a1b1fc2418e0f622a6acc99f2dff9663ed36c20f772b0c4724600af2d4b95a4ac21b1611a6e79447fd01f2e188f1a8bff5e0e0b4bd0a98431cea133b581dcd2230967fa60bfd644620a8d5d08aaabb4e7288fe6a79771da0915cbaa689fe9fa312db62cf7d20b6a8bd57dec44337bd0bb611e794da0a2d039314db08f72b28e2cd662199c26f186e623ebc47b9d68783d0e279ce18b621823e6432a6368b653a0e5ded85acc0f7da1d62dc3bcd392066092db62bd0a97ebdfac326226f2564ecfdf7269d06e4e80bcc865ace0a81608d0e30bf0491eef4442518f902e1a13c2fc745c1cd9bde69059909fd20f738e50f7eb821a59f3af0b1594628f469283b22707dd5a839d3f93db802b31b4acbef90670020b5ee69c475ca365591c5a0d28c3580d870e5dc4f26ca94b9152c8d239b2dff532a0bfb912d9a14d80e3c34f0db4ea11f09249e35e17638db85068d8d9e111fd97b1a20477e0a564d2f2ec9c8f33b80d01a4ddc2b137262ba2b98bc418751ab37f8995471631a2e6569acce305e84aef2248e4a278fafd6e36b54427dbe488b7a0a782a676a19d135bf93684f1564f018f76b69938b5193c9b1534e2f70ad8b0682691e8288fcd78642fe3959d2b531ddeea39552544f4cc9da9f1cc829950c29cbf846e387e3bc9a634975e497c15351ac08b894aca92e598a16729691bb6aa25811ec88d321c4107e6c14b6955e3dace5e6bd18a46a626ee8cc2abcccbae758187db228e2d6c7e0e7444a4bb388b4026a979d833f8386aa1032098e1e3a3ea9f47e2286d7c1a7616fee3f1b54ff2db710d815faadcd38e130de8c2187e4e77e8a00552288a8e42ec0bc5ec60f0cba98a1a5dca92e27a64df58ec39a25af4d37870b4eb875adb11bf6c31b2a4db2d9424e7969b2a1718343b26e33cc98bd0e165bbbf62407833e60bcf54f24346798b402805af45ad41112388f26bd35e2a7aa7d3a5b1c83a1870658ebb807e0a1ea3f6ba92c9dd1bb8f889ece9fb9533f0611c2ac4ffc294a87c924d483d69a45248838cf4fbb262eb01e22c0e1413d4b29d022b2df17ff97453ebc7c89c4b79bae0c9f8d64c5442ab6421bfc99f967e50de17a7a0e1aa0c879f2a700377cce09f0c0f1d1520b0f5bf0b2b972b7cc646ac782be2d157caeaa02999a411633e2c860ce1763f575607a6edd9272326a9ada7bb9328dedfc9c74caa4a681e5408892dc24117ecafe5863fd75c28aa215440e1b45d2e7c949e31222126ea8de91f5b91718b8033a5aaa8d45ddccd120e663892cbd87be49e88a400d6afb88baa0376d85d0fd8a29d077102a2d0466e381a4c47d5612ed5841e2f14091a8ace4067f683646b4a73cfffd76607cf3fe1094901a41bd20b795fec6a382d75deb8e82c2b21b100cf46946d86c821bdc3f1e6fd16f64d14bfc1e6d845afc00a3020ecb4b0e1b6482c863477bfe7ebf942dd24bba221f16464b21b704b05dfa3f35dab9509a2ef9426c429da2f683b6eec315ef4967a99bddc4586dccee5141fcc5a45f5687c29a2eb530fe6367e94e18daf5ad9c49a7c134fa14d3470e8ef41585363fe114b7713ef3767cef99d9c6b56a7ff4acdf771c0eebaaf6d7bd26380eae21b3f9c4c9a5b27ae066de37bd55693efc84e90cc2900658949a749d3fe4b91d79e1c55a4aa423314a816bc420f9d4c205c2620d0e520434283a3b457da6ef3bf970adc8811ded0b775a74ed7799c0451df2bf0d0ea6e5038b1bf653dda6e22122fa323d8bac3b23fc0e64ee9480be0d17ebde61a89e57383a9152bfb462b284b8e9142b064df8e6e5aaec6414076d254f0ed3432cec7b594f9d8aa1faca69dc9b8560e0fb9d914aefaf1e2f898a66bad49b8022f07d2eafc2738f3c91decf8087213f4749c86bd427801e5585bf1c27c575794b7d8636db4bc9fa3ebc660c4639d464d35170f079985ab07cf9298adc9a05ffbb5a4765c892b27a811e3885f425e4b331e01ba722432ac1bd79d33bed8c208888d5e0e57dce8f23305c2bacc1017b9f3270d64c8097325a244f267023fb8f319042df20b1f38fabc33987db39f1ae0d6246c113445187fe9ea8ee031d71572db5a14f91bb14d1be4e5c5ccdf5b494fa411bacfdf00932777704ec1fd25774dc967a7639b4ede60de05dd62e1695ee35141ca1bf3dddbc956b576801c36266b7533d9e9d2c1f621410b4adc1793b17597f3980a820be4836236843f804059863b648983970f10e108e155c74707aa231c906af06c234696e0b70cc39b7007e719622ce81f2d9e85667f4786289f573330e42459f5589df254d14fe8123b10b89809d697972d8975ee67fb0441dd23b4a6b82468f09aa47b3bf005b0d4ffb1d0faccf4bb102d5bdf19d7731b244db5c1c308e00e7a3679f4d3c4af328ccd54a4af4dc7dda75ea259eabff1c3e923a846c2d7e224eb95b32c94357b76914ae166f9c1bd05b83a76ae467fc9405411134eb2eea970ff9c685ccad9f543b569ef1521d0135046ec795628699fc6b9594bef07895210925cd34d0a8c4b6bd0ca847f2deaa0f9fea7d07ad46276a9df5a60773d9425b56ba90b5e5376e1d6f440b443e3e0bbade586ca97044cbc9704f92320a18d14def3fac2f329a2fee019a7b7f94c2a7b180585d51bd9b1629158252e8c19d1c48221d1d4443a4de052e713091d146f8eeedfd8f659e02dab91b3c69d04330038ea90311629d1a264fd519df148451fdd513d1b06de5e984ad12da1a52219538b80fceddfb8a6acae2081353c5f2499764cefddc34b297cc7197c742db7194cec43e4f2055ff1083fcbae4de279e864e79f0b43eb1cb3190bd14e2ac0eed50931335abc2b8f5173e608d67555b3c6239cbe6e938478d639a7d8e8f2c7f68deee4ae9332c2bea0b067b6801a4416abd927e9fd26064073af14d5ca78a8e8c8ee10716607f84bd54b750f4dbed8b6846fa97a94f9a06fb29d4d232deaa72160e86a9c38c27d9e34ba0690478e9e8f4734d5d89da8b4d4bd71548f18545ed08abf4a0e8813dd4baf81bbe6d821b9641ec21655c76969efbad934aa7cd2f9aabb783635e10d09fbdcc5695bf179b5024839a7597b8f09acdf4fcc31af1a4017426db6f0cad07f9b752525ea7ec8a51f6d8e3ecf8f6cf7436b01c6e8409183bff2b44575c7555e6a04de0d85a3f9083d016585f4f5438d2861ded94d39189bb1c7c642b9382842b44ee5485530c7b3bb9b405519159db1c14b497e1e947bd65618577dcdf5faad97a56eeab89717e1d69277dead690e38efde1b6b58b42ffa1e9a90e3604695e584481af87cb2ddc41df3834ac1412512be1f08e21e526725b07a667d41363a423f7066c9428116b1f345996a150dba20eae15026a1207695fe3a04bd683ccb0eaca3696d6a0b5ee1c22d7bc84ccf695ad65613837b8a4966932195c75831fc2b9dda0a4ac06bb7a0da1124cfc987cf7408f525dded63288383ff57c0340686f300ca9cc00392366ac57daf429cd7de699bef71783d40d907ded55de6d403fd1cb17be6e46a7b9d6f4669aa4484a119504579d1d3f20218897a66386b35cdc5297c5fb458432657f06fbb9cc9571e34a0dc7c3f3d3021a70c2b641eb37c8f8888b50da0a0ec8e9e0e37e36ca67d37844ca7cbaeeccc2f9dd9d80c309ffcaacf3df2b7b509f2ede00b5b2ab1e634d6bb1e93837f326b0c7dd1d670769c12dcdfd3bccfdbaf7f0558763d73d07cd2c3a9549717a1be8c8396631d0632d88adcf7ec48b83334f3734a382fdd9950e8d9f02c562924f885a70685e41ae7949a165a0a0c7aee0d690f4c33a87d6f388a6c70d1f2f93624ca76b5c6d6d42ec9c088789d25c3c6357fc6d14ce2ebccdd81f10fefe09abc59c6a8e5a6ab044d9a66ae3ef8d33f5b95337dbef0828fdbc60109495117cd484f3a2b6955cbb3afccf8d18a8071879af4d59927205f9a9f47a17d7025a4f0197cf40cb058e489592367ecc1e645f1753822c925abe41c6b358a8df58548494289453aabaad6e9c8afd199ff56254edf2442c1a6c2dc828854460c98650935d154da256d1b71a75936fc462c7965e5548f7d4e690e5d4e580244e8134ef820ef79188df534edff04d44a6ec4a4714a2cd4f58a92e6a647743b07bdc4c9c1cc961595ee3c625ca16769f3706</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="Hey, password is required here.">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大学生应知应会(1)：从“伸手党”到“合作者”，你必须学会的提问艺术</title>
      <link href="/2025/08/11/2025-08-11-%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%BA%94%E7%9F%A5%E5%BA%94%E4%BC%9A(1)/"/>
      <url>/2025/08/11/2025-08-11-%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%BA%94%E7%9F%A5%E5%BA%94%E4%BC%9A(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>前不久我刚刚比完电赛，在收获之余，我也观察到一个让我深思的现象。</p><p>备赛期间，我将一个自己整理的电赛报告模板开源到了 <em>GitHub</em>上，希望能帮到更多同学。然而，评论区和私信里，数量众多的“打不开”、“求网盘”、“怎么下载？”让我意识到，一个看似简单的步骤，却成了许多同学无法逾越的鸿沟。</p><p>这让我深深地感到，我们的教育体系中，从高中到大学，存在着一个巨大的“断层”。高中阶段，我们习惯了被动接收、被精心安排好一切的学习模式；而大学，尤其是理工科，要求我们成为主动的“信息猎人”，去探索、去筛选、去独立解决一个个未知的问题。<em>GitHub</em>，这个全球最大的工程师社区，恰恰就是这个新世界的大门。如果连门都找不到，又何谈去探索门里的宝藏呢？</p><p>这种信息检索能力和问题解决能力的缺失，对一名大学生（尤其是理工科大学生）的成长是极其不利的，它会像一道无形的墙，限制住你的发展。</p><p>因此，我萌生了撰写 <em>《大学生应知应会》</em> 这个系列的想法。目的很简单，就是希望将我的一些经验和思考分享出来，帮助那些即将踏入大学校门的准大学生，以及那些已经身在其中但仍感迷茫的同学们，顺利地跨越这道“断层”，完成从“高中生”到“合格的大学生”的关键一跃。这个系列不仅会有一些大学常见工具的使用教程，也会有一些我个人思考总结出的做人做事的道理。当然前者很有可能是不完善的或有错误的，后者很有可能和你的想法不一样，希望大家多多包涵，也可以联系作者一起讨论。文中所讲述的“客观事实”是我见过普遍的现象，并非100%如此，请读者注意分辨。</p><p>希望这个系列，能成为你们手中的一份 <strong>“大学生存指南”</strong>，帮助你们更快地适应新环境，掌握新工具，建立新的思维模式。</p><h1 id="一、欢迎来到“开放世界”"><a href="#一、欢迎来到“开放世界”" class="headerlink" title="一、欢迎来到“开放世界”"></a>一、欢迎来到“开放世界”</h1><p>绝大多数同学经历的高中生活都是一样的，类似于游戏里的 <em>“线性任务”</em>，统一的主线就是<strong>高考</strong>，老师们都是引导你做任务（追着你喂知识）的NPC。但是到了大学，可以说就是一个完全的开放世界：遇到有责任心的班主任一年能开三四次班会，没责任心的四年不一定见得到几次；上课的老师也许会在课后回答你的问题，但是几乎不可能在意你成绩的好坏；导员和学院领导都是只顾自身利益，你找不到工作也得在就业书上签字。</p><p>你知道所有宝藏都藏在山顶，你也知道自己的专业通向山顶的道路好像就这么几条，但是你不知道怎么走。所以，你首先要做的就是 <strong>“问路”</strong>。但是，你真的会问路吗？</p><p>让我们来看这两个例子：</p><p><img src="https://pic1.imgdb.cn/item/689959c458cb8da5c81838c6.png" alt="方案"></p><p><img src="https://pic1.imgdb.cn/item/6899599358cb8da5c818374b.png" alt="网盘"></p><p>这是我在B站分享的电赛报告视频后，评论区和私信出现的比较典型的反面“问路”例子。他们看起来都还挺<em>有礼貌</em> 的，但是问问题完全没有<strong>问到点子上</strong>。第一个人问的问题我到现在还没听懂——一个模板用的什么方案？第二个问题更是典型：在面对一个未知的问题，不去想怎么解决，反而是请求UP主在自己熟悉的地方重新分享。这样“问路”，除了<strong>菩萨</strong>我想没有人会回答吧。</p><h1 id="二、“姿态放低”有用吗？"><a href="#二、“姿态放低”有用吗？" class="headerlink" title="二、“姿态放低”有用吗？"></a>二、“姿态放低”有用吗？</h1><p>在聊怎么正确“问路”前，我们先来分析一个很流行的说法：“学长学姐没有义务回答你，所以提问时姿态要放低。”</p><p>这话有道理吗？当然有。前半句是事实，后半句是礼貌。但如果把它当成提问的“唯一准则”，那可能就走进了一个误区。</p><p>我们先想一下，<strong>提问的本质是什么？</strong> 它不仅仅是获取信息，更是一种社交行为。一次提问，就是一次对话的开始，也是一次潜在联系的建立。</p><p>如果一味地、过度地强调“姿态放低”，可能会带来几个问题：</p><ul><li><strong>让你变成了“乞求者”：</strong> 过分卑微的心态会让你紧张、自卑，甚至不敢提问，白白错失了获取信息的好机会。</li><li><strong>小看了对方的格局：</strong> 你以为别人帮你只是因为“人好”？其实，分享和解答能给人带来很多东西，比如：<ul><li><strong>成就感：</strong> 看着自己的经验帮到别人，真的很酷。</li><li><strong>责任感：</strong> 维护一个良好的社群氛围，帮助新人是“前辈”的自觉。</li><li><strong>教学相长：</strong> 在解答的过程中，自己的思路也会更清晰。</li></ul></li><li><strong>混淆了“提问”和“伸手”：</strong> 一个经过思考的、有准备的提问，本身就是对他人时间的最大尊重。</li></ul><p>所以你看，比“姿态放低”更重要的，是你的问题值不值得被回答，也就是 <strong>“高质量提问”</strong>。</p><h1 id="三、提问的核心方法论"><a href="#三、提问的核心方法论" class="headerlink" title="三、提问的核心方法论"></a>三、提问的核心方法论</h1><p>其实，这件事我们可以联想一下中学时请教数学题的场景。</p><p>一个学霸，更愿意回答下面哪个问题？</p><p>A. “这道题怎么做？”</p><p>B. “这道题我用了公式A，算到这里卡住了，是不是我的思路有问题？”</p><p>答案显而易见。从A到B的转变，就是提问质量的飞跃。我们可以把它总结成三个小技巧：</p><h2 id="1-先自己走几步，再请人指路"><a href="#1-先自己走几步，再请人指路" class="headerlink" title="1. 先自己走几步，再请人指路"></a>1. 先自己走几步，再请人指路</h2><p>提问前，最好先说明你已经为此付出了努力。这不仅尊重了对方，也帮对方节省了大量时间。</p><p>比如这样说：<br>“学长&#x2F;学姐好，关于XX问题，我自己在网上查了一下，但A资料和B资料说的有点不一样，所以想请教一下您的看法。”</p><h2 id="2-问具体，别问“天气”"><a href="#2-问具体，别问“天气”" class="headerlink" title="2. 问具体，别问“天气”"></a>2. 问具体，别问“天气”</h2><p>宽泛的问题只会得到宽泛的答案。问题越具体，得到的答案才越有价值。</p><p>比如：<br>把“这个专业怎么样？” 升级为 “学姐，如果我想走XX方向，大一期间在课程学习和课外实践上，有什么比较关键的建议吗？”</p><h2 id="3-有始有终，让帮助更有温度"><a href="#3-有始有终，让帮助更有温度" class="headerlink" title="3. 有始有终，让帮助更有温度"></a>3. 有始有终，让帮助更有温度</h2><p>这是很多人都会忽略的一点。在得到帮助后，花一分钟告诉对方后续结果，完成一个“反馈闭环”。</p><p>比如：<br>“学长，上次听了你的建议，我后来用XX方法把问题解决了，真的非常感谢！”</p><p>这句话会让帮助者感到自己的时间和善意没有被浪费，获得满满的价值感，这样就建立起了一个非常棒的长期关系。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大学里的求助本质是 <strong>“合作”</strong>，而非 <strong>“乞讨”</strong>。你的目标是成为一个有价值的 <strong>“合作者”</strong>。</p><p>作为一个合格的大学生，必须要掌握高质量提问的三大支柱，并应用到与老师、学长学姐的每一次沟通中。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>亡命之徒</title>
      <link href="/2025/08/04/2025-08-04-%E4%BA%A1%E5%91%BD%E4%B9%8B%E5%BE%92/"/>
      <url>/2025/08/04/2025-08-04-%E4%BA%A1%E5%91%BD%E4%B9%8B%E5%BE%92/</url>
      
        <content type="html"><![CDATA[<h1 id="亡命之徒-纵贯线"><a href="#亡命之徒-纵贯线" class="headerlink" title="亡命之徒 - 纵贯线"></a>亡命之徒 - 纵贯线</h1><p><img src="https://pic1.imgdb.cn/item/68905d8458cb8da5c803be2e.jpg" alt="专辑封面"></p><ul><li><strong>曲风</strong>：摇滚</li><li><strong>发行时间</strong>：2008-12-17（单曲）</li><li><strong>专辑</strong>：北上列车（2009-09-15）</li></ul><hr><h2 id="小介绍"><a href="#小介绍" class="headerlink" title="小介绍"></a>小介绍</h2><p><strong>纵贯线 (Super Band)</strong> 是由<strong>罗大佑、李宗盛、周华健和张震岳</strong>四位华语乐坛举足轻重的音乐人于 <strong>2008年</strong> 组成的一个特别企划乐团。这个名字取自台湾省南北向的火车线路，寓意着他们将合力在音乐的道路上越走越远，连接不同世代的音乐情怀。</p><p>这个组合的诞生在华语乐坛引起了巨大的轰动，因为它汇聚了三代音乐人的精髓：</p><ul><li><strong>罗大佑：</strong> 华语乐坛的“音乐教父”，作品深刻，富有批判精神。</li><li><strong>李宗盛：</strong> 华语乐坛的“情歌大师”，歌词细腻入心，被誉为“最懂女人心”。</li><li><strong>周华健：</strong> 华语乐坛的“国民歌王”，歌曲积极向上，传唱度极高。</li><li><strong>张震岳：</strong> 台湾乐坛的“摇滚小子”，风格独特，充满年轻活力和叛逆精神。</li></ul><p>《亡命之徒》由李宗盛、罗大佑与周华健作词，张震岳作曲，于2008年12月17日以单曲的形式发行，后收录在纵贯线2009年发行的专辑《北上列车》中。该曲也是纵贯线乐队组团后创作的第一支单曲。</p><hr><h2 id="我想说的"><a href="#我想说的" class="headerlink" title="我想说的"></a>我想说的</h2><p>对于纵贯线这个乐队，我第一次听到还是在小学那会，我爸的车载光盘《华语精品》上。当时听了<em>纵贯线兄弟姐妹</em>和<em>亡命之徒</em>两首歌，但也只是有印象，觉得好听罢了。现在长大了又重新接触华语，又重新听了<em>亡命之徒</em>，有了新的感悟。从音乐性而言，这首歌的作曲、编曲和演唱都无可挑剔，特别是最后的副歌部分，罗大佑整首歌没有唱一句主词，但是他的充满沧桑感的声音，唱出的和声让整首歌更上升了一个档次，可以说是华语乐坛T1级别的和声了。</p><p>再从歌词的角度而言，三个作词的老炮饱含着对青年的希望，他们用自己的经历和感受，鼓励青年冲破迷雾，“迎风向前是唯一的方法”。</p><h3 id="Enjoy"><a href="#Enjoy" class="headerlink" title="Enjoy~"></a>Enjoy~</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电赛经验总结（纯个人版）</title>
      <link href="/2025/08/04/2025-08-04-%E7%94%B5%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
      <url>/2025/08/04/2025-08-04-%E7%94%B5%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>写在前面</strong></p><p>在备赛的时候就常常在想写一篇文档，总结一下自己的经历和经验，如果有些许能帮助到后来人也算是我的幸运。本文档完全是基于我自己个人的经验，只适合参考并不具有普适性；本人也只是一个普通的大二学生，说出的话并不权威也很有可能是不正确的，望各位读者审慎视之。又由于本人是负责软件的，对于硬件和视觉部分并不了解，在文中也就不表。</p><h1 id="0-要用好的硬件"><a href="#0-要用好的硬件" class="headerlink" title="0 要用好的硬件"></a><em>0</em> 要用好的硬件</h1><p>之所以把这一项放在第一个位置，且用 <em>0</em> 标注，是因为我觉得这是我备赛以来最重要的部分，也是我觉得自己做过的最正确的决定。“巧妇难为无米之炊”，大概就是这个道理。如果你有足够的软件技术，那么硬件部分的硬伤是完全可以弥补的，但是从效率上而言，甚至可能比不上一个技术不强但是硬件很好的队伍。</p><h2 id="舍得花钱"><a href="#舍得花钱" class="headerlink" title="舍得花钱"></a>舍得花钱</h2><p>以我们队今年参加的赛题 <em>2025年E题</em> 为例，我们最后的作品，总计价值超过一千元。那么在备赛周期中，我们的准备更是大幅超过这个数，总计可能超过3k甚至4k。我个人用过不少产品，有些很便宜有些很贵，大部分时候，贵的产品是远远比便宜的产品好用的。比方说逻辑分析仪，我使用的是正点原子 （<del>挣点元子</del>）的标配400+元。相比那些几十块的小分析仪不知道要好多少。在调试的时候，拿出逻辑分析仪一测，很快就能定位问题所在，相比之下之前没有逻辑分析仪的苦日子我是真的不想再过了。这400块，是我个人认为我备赛周期最正确的付款。</p><p>又比如二维云台，我们一开始使用的是舵机，用于 <em>2023年E题（激光追踪）</em> 的练手。即使我调出来一个非常好的PID用于追踪色块，可是由于舵机本身的精度限制，我们还是遇到了不少困难。相比之下，我同学的队使用伺服电机，直接就把这道题变成了“水题”，可见一个好的硬件是多么重要。</p><h2 id="尝试新东西"><a href="#尝试新东西" class="headerlink" title="尝试新东西"></a>尝试新东西</h2><p>一般来说，新的产品是要比旧的产品更好用。例如<strong>陀螺仪</strong>，我们一开始用的是经典的<em>MPU6050</em>，配合其DMP库的姿态解算可以得到一个初始漂移仅3度左右的Yaw角，在静止8秒之后Yaw角就可以几乎稳定下来（其DMP库的特性）。但是由于<em>MPU6050</em>本身已经停产，市面产品不是国产仿造就是翻新，良莠不齐，所幸我们买到的都是可以正常使用的，但是我同学的队买的2个6050都是完全不能使用，Yaw角漂移可以当做秒表使用了。后来我们决定抛弃6050，尝试使用比较新的产品<em>ICM42688</em>。配合一点软件补偿角速度漂移，使用之前同样的四元数姿态解算算法，我们几乎得到了一个无初始漂移的结果。这并不是说不能使用<em>MPU6050</em>，相反对于电赛的要求而言，6050的精度是完全足够的，参加电赛的队伍普遍使用的都是6050.但是它作为<em>旧时代的残党</em>，我们现在有了更好的选择，何乐而不为呢？</p><h1 id="1-要有好队友"><a href="#1-要有好队友" class="headerlink" title="1 要有好队友"></a><em>1</em> 要有好队友</h1><p>这一项的重要性也不需要我多说。如果你的队友够强，你甚至可以摆4天3夜让你的队友带你捧杯（<strong>但是我极力反对和谴责这种不要脸的行为</strong>）。但是很多时候大家的水平差不多，这个时候才是体现出“好”的作用的时候——相处融洽、分工明确。</p><h2 id="关于分工"><a href="#关于分工" class="headerlink" title="关于分工"></a>关于分工</h2><p>我们队的分工是非常清晰的：<strong>硬件、软件、视觉。</strong> 这里的软件和视觉之所以也要分开，是因为通常而言摄像头可以被视为“上位机”，不直接参与底层的控制，例如小车的行驶，云台的转动等等。通过这样的分工，每个人确定好自己的工作就可以实现功能上的解耦（在软件中我们叫这个 <strong>“高内聚低耦合”</strong>）。当你不需要去管自己分外的事情，专注于一件事的时候，效率会提升不少。当然比赛过程中也不乏视觉、硬件都做完了只看软件的情况，此时就需要三个人合作同一件事了。</p><h1 id="2-重视基础"><a href="#2-重视基础" class="headerlink" title="2 重视基础"></a><em>2</em> 重视基础</h1><p>上学的时候老师就一直强调 <strong>“基础不牢，地动山摇”</strong>，在面对任何问题时实际上都是这样。上了大学之后很多人学期内不学习，把所有的任务都压给期末前一周，指望速通（我并不是谴责这种行为，因为我本人也这样），你当然也可以把这一套挪用到电赛来，“速通”电赛小车之类的。但是我极力反对你使用这种方法，因为电赛并不是一成不变的，近几年出的题目灵活性都较高，用“速通”的办法只会让你思维僵化。如果你提前一个月备赛，你完全可以抽出10天的时间，先深入学习单片机在电赛可能用到的所有外设，整理成笔记，然后动手实操，写一些类似于电机驱动、编码器等等普适性的模块，这不仅是为比赛可能出到的题目做准备，也是增进了你对单片机外设的认识，解决问题时也就更轻松。</p><h1 id="3-善用AI（大语言模型、Agent）"><a href="#3-善用AI（大语言模型、Agent）" class="headerlink" title="3 善用AI（大语言模型、Agent）"></a><em>3</em> 善用AI（大语言模型、Agent）</h1><p>对于一个现代的大学生而言，使用AI是一项必不可缺的技能了。但是什么时候用、怎么用，这里面也有讲究。</p><h2 id="写程序的时候"><a href="#写程序的时候" class="headerlink" title="写程序的时候"></a>写程序的时候</h2><p>AI强大的编码能力，使得他可以轻松生成大段的代码，但是很多时候他可能不是准确无误的，而且很有可能他和你的思路完全不一样，导致你要在这里浪费很多时间。我使用AI的思路是，先完全确定好这一部分的编程思路，具体要用到哪一些外设或方法，然后告诉AI，让AI生成一些初步的代码，我再检查和修改。一定不能所有的代码全交给AI写，不然这样下去你的代码很可能就变成了 “💩山”，连你自己都看不懂了。</p><h2 id="调试的时候"><a href="#调试的时候" class="headerlink" title="调试的时候"></a>调试的时候</h2><p>当你面对一个棘手的问题，不知道问题的原因是哪里的时候，你也可以尝试去问问AI。很多时候如果你不知道问题的原因是哪里，那就是这个问题已经超出了你的知识范围了（前提是你已经检查了所有你能检查的地方，这一点在下面会讲到），此时去问问AI，也许他就能给出解决的办法。</p><h1 id="4-调试的黄金准则"><a href="#4-调试的黄金准则" class="headerlink" title="4 调试的黄金准则"></a><em>4</em> 调试的黄金准则</h1><p>这是我自己亲身经历，用“血与泪”总结出来的教训。如果你能使用这种准则去调试，相信BUG很快就能被你精准定位并解决。</p><p><strong>例：二维云台绑上OpenMV追踪色块实验，调PID调一万年也调不好，最后发现上下舵机的PWM通道是反的。</strong></p><h2 id="自下而上，逐层验证"><a href="#自下而上，逐层验证" class="headerlink" title="自下而上，逐层验证"></a><strong>自下而上，逐层验证</strong></h2><p>当系统不按预期工作时，永远不要直接去怀疑最顶层的算法。要像一个侦探一样，从最基础的物理层开始，一层一层地向上排查。</p><h3 id="第零层：物理层"><a href="#第零层：物理层" class="headerlink" title="第零层：物理层"></a><strong>第零层：物理层</strong></h3><p>这是最常被忽略，但也最致命的一层。在触摸键盘前，先拿起万用表。</p><ul><li><strong>电源检查：</strong> 模块的VCC和GND引脚，电压是否正确？电池电压是否足够？</li><li><strong>连接检查：</strong> 信号线是否虚焊？插头是否松动？有没有一根线插错了引脚？（比如例子，如果用逻辑分析仪测量两个舵机的PWM引脚，会立刻发现信号与预期不符）</li></ul><h3 id="第一层：驱动层"><a href="#第一层：驱动层" class="headerlink" title="第一层：驱动层"></a><strong>第一层：驱动层</strong></h3><p>在这一层，我们要验证MCU能否“一对一”地精确控制每一个硬件。这是在<strong>验证你和硬件之间的“契约”</strong>。</p><ul><li><strong>最小化测试：</strong> 放弃所有上层逻辑，写一个最简单的测试程序。比如，只调用最底层的PWM输出函数，<code>Set_PWM_For_Channel_5(duty_cycle)</code>，然后去测量5号通道的引脚，看波形是否正确。</li><li><strong>隔离变量：</strong> 比如例子，就应该写一个独立的测试函数，如<code>Test_Servos()</code>，在里面分别调用<code>Set_Upper_Servo_Angle(90)</code>和<code>Set_Lower_Servo_Angle(90)</code>，然后观察哪个舵机动了。问题会立刻暴露。</li><li><strong>验证返回值：</strong> 官方的HAL库或DriverLib函数，通常会有返回值（如<code>HAL_OK</code>）。永远不要想当然地认为函数调用成功了，必须检查返回值。</li></ul><h3 id="第二层：功能层"><a href="#第二层：功能层" class="headerlink" title="第二层：功能层"></a><strong>第二层：功能层</strong></h3><p>在这一层，我们验证封装好的函数和模块的内部逻辑。</p><ul><li><strong>单元测试：</strong> 对每一个功能函数进行测试。比如，你有一个将角度（0-180度）转换为PWM占空比（500-2500us）的函数<code>map_angle_to_pwm()</code>，你要单独调用它，传入<code>0</code>, <code>90</code>, <code>180</code>等边界值，看它的返回值是否符合预期。</li><li><strong>接口检查：</strong> 检查函数之间传递的参数。单位对不对？数据类型对不对？正负号对不对？（比如，一个函数需要弧度，你却传入了角度）。</li></ul><h3 id="第三层：算法层"><a href="#第三层：算法层" class="headerlink" title="第三层：算法层"></a><strong>第三层：算法层</strong></h3><p><strong>只有当前三层都100%确认无误后，你才有资格怀疑你的算法。</strong></p><ul><li><strong>逻辑审查：</strong> 这时才开始分析你的PID逻辑、状态机跳转条件等。</li><li><strong>数据可视化：</strong> 使用串口或逻辑分析仪，将算法的所有输入、输出和中间变量全部打印或显示出来，观察它们的动态变化，判断算法行为是否符合理论。</li></ul><h2 id="调试的三个核心心态"><a href="#调试的三个核心心态" class="headerlink" title="调试的三个核心心态"></a><strong>调试的三个核心心态</strong></h2><ol><li><strong>怀疑一切 :</strong> 不要相信任何一行你没有亲手验证过的代码，无论是你自己写的，还是从网上复制的。不要假设任何一个模块是好的，直到你亲手测试过它。</li><li><strong>分而治之 :</strong> 当一个大系统不工作时，尝试将它拆分成几个小块，或者注释掉一部分功能。如果注释掉某段代码后，系统恢复正常了，那问题就一定在这段代码里。</li><li><strong>小黄鸭调试法 :</strong> 把你的问题，清晰地、逐行地，讲给一个不会说话的物体听（比如桌上的一个橡皮鸭子），或者讲给一个对你项目完全不了解的同学听。在你试图把混乱的思路组织成语言时，往往自己就能发现逻辑上的漏洞。</li></ol><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>想说的很多，但是写成文章又觉难以下笔，只能写这么多了。最后想聊聊参加电赛的意义问题。我一开始也不太清楚我打电赛真正的目的是什么，曾经我也想过如果做不出来要不要去找代做等等问题。但是在我备赛的过程中，我慢慢意识到实际上电赛拿不拿奖并不是一件多么重要的事情。就好比高考，我曾经为了高考努力了3年，但是在高考结束的刹那，高考考的怎么样就并不是一件很重要的事情了，重要的是你的人生的一个新阶段开始了，重要的是你在这个过程中经历了什么。电赛也是一样的，它督促我学习，让我从一个半月前只会点灯的小白，到现在可以有自信独立完成一个项目，这才是我真正的收获——成长。很久以前我是一个很讨厌这种大话的人，但是现在我自己经过了这种过程之后，我觉得这话说的真是有道理。这才是我认为参加电赛真正的意义，他比什么能写进简历里的一个奖项重要的不止多了一点。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电赛 </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电赛记忆</title>
      <link href="/2025/08/02/2025-08-02-%E7%94%B5%E8%B5%9B/"/>
      <url>/2025/08/02/2025-08-02-%E7%94%B5%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="独家记忆之电赛"><a href="#独家记忆之电赛" class="headerlink" title="独家记忆之电赛"></a>独家记忆之电赛</h1><p><img src="https://pic1.imgdb.cn/item/688e17f758cb8da5c8fe80c7.jpg" alt="挂牌"></p><p>8月2日晚8点，四天三夜的全国大学生电子设计竞赛就结束了。这是我大学生涯参加的第一个，也很可能是最后一个比赛了。回顾这40多天的备赛过程，感觉非常的过瘾。自己自高中以来，已经有近两年没有这么努力的为一件事情耗费大量的精力了，对自己而言，这次比赛虽然还没有出结果，但是我已经收获了我可以收获的最好的东西————个人的成长。</p><p>首先要感谢<em>周</em>和<em>许</em>，没有他们俩在队伍里，我自己一个人根本无法完成这么高强度的任务，相比之下我个臭写软件的就是个混子。即使我们最后倒在了通向发挥部分的道路上，但是对我而言已经足够好了。<strong>竭尽所能，即为英雄</strong>，我相信我此刻真正践行了这句话。</p><hr><p>备赛和比赛让我经历了太多的第一次：我第一次和别人通力合作，第一次完成一个看起来足够强大的项目，第一次熬通宵，第一次差点碰上实验室火灾 <del>（这还是和通宵一起经历的）</del></p><p>也许这次比赛我最终无缘TI杯，但是那对我而言也已经无所谓了。曾经的我听大家说电赛含金量高我就来了，但是直到比完赛后我才明白，电赛真正珍贵的东西是督促你不断地进步，不断的成长，相比这些，什么奖啊都不再重要了。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kallocain(Original Mix) - Endre</title>
      <link href="/2025/07/27/2025-07-27-Kallocain/"/>
      <url>/2025/07/27/2025-07-27-Kallocain/</url>
      
        <content type="html"><![CDATA[<h1 id="Kallocain-Original-Mix-Endre"><a href="#Kallocain-Original-Mix-Endre" class="headerlink" title="Kallocain(Original Mix) - Endre"></a>Kallocain(Original Mix) - Endre</h1><p><img src="https://pic1.imgdb.cn/item/6885f57158cb8da5c8e4de91.jpg" alt="专辑封面"></p><ul><li><strong>曲风</strong>： 电子 - Trance（迷幻电子）</li><li><strong>发行时间</strong>：2004-03-15</li><li><strong>发行厂牌</strong>：Anjunabeats</li></ul><hr><h2 id="小介绍"><a href="#小介绍" class="headerlink" title="小介绍"></a>小介绍</h2><p><em>Kallocain</em>（中译《卡洛卡因》），是瑞典著名作家、诗人卡琳·博伊（Karin Boye）在1940年发表的一部经典反乌托邦小说。它与奥尔德斯·赫胥黎的《美丽新世界》（1932）、叶夫根尼·扎米亚京的《我们》（1921）以及乔治·奥威尔的《一九八四》（1949）并列，是20世纪反乌托邦文学的四大里程碑之一。值得一提的是，它比《一九八四》早了近十年，却惊人地预见了其中的许多核心概念。</p><p><del>想必Endre是看过这部作品之后，对书中的世界心驰神往，于是创作了如此佳作</del>，带领听者走向一个理想国。</p><hr><h2 id="我想说的"><a href="#我想说的" class="headerlink" title="我想说的"></a>我想说的</h2><p>自打我听Trance以来，听过了非常多的佳作，不乏能让我感受到曲中所描摹的世界的作品。但是能让我越听越上头，越听越爽，甚至觉得前无古人，后可能也没有来者的作品是只此一位了。也刚好其曲名符合我心中对我的博客命名的想法，<em>Kallocain</em>这个名字也就这么来了。在进入我的博客后，你就能听到这首歌，希望这首歌能和我的网站一起带你进入一个理想的国度。</p><p>每个人听Trance的感受都不相同，有些人可能觉得这么好的旋律和节奏，不跟着舞动是一种浪费（毕竟Trance也算是EDM的一个分支），但对我而言，很多Trance适合闭上眼睛，全身心的投入进旋律中，像这首Kallocain一样，投入到那个美丽新世界中去。</p><h3 id="Enjoy"><a href="#Enjoy" class="headerlink" title="Enjoy~"></a>Enjoy~</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初登场</title>
      <link href="/2025/07/24/2025-07-24-%E5%88%9D%E7%99%BB%E5%9C%BA/"/>
      <url>/2025/07/24/2025-07-24-%E5%88%9D%E7%99%BB%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>在备赛电赛的间隙，抽出了一点时间做了这个博客的框架，稍稍美化了一下主题。在紧张的时候做点闲东西也能放松一下，就是脱离备赛感觉有点愧疚。</p><p>以后在这里更新一下学习过程中遇到的困难和解决办法，也写一些随笔，希望这个网站的存在能让自己不辍笔耕，对自己也算幸事一件。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
